var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to2 = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to2[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to2[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to2;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = Function.call.bind(Object.prototype.hasOwnProperty);
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var checkPropTypes = require_checkPropTypes();
    var has = Function.call.bind(Object.prototype.hasOwnProperty);
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x2, y) {
        if (x2 === y) {
          return x2 !== 0 || 1 / x2 === 1 / y;
        } else {
          return x2 !== x2 && y !== y;
        }
      }
      function PropTypeError(message) {
        this.message = message;
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            if (checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
              return null;
            }
          }
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (!checker) {
              continue;
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (!checker) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module2) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/flatpickr/dist/flatpickr.js
var require_flatpickr = __commonJS({
  "node_modules/flatpickr/dist/flatpickr.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.flatpickr = factory());
    })(exports, function() {
      "use strict";
      var __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __spreadArrays() {
        for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
          s += arguments[i].length;
        for (var r = Array(s), k2 = 0, i = 0; i < il2; i++)
          for (var a = arguments[i], j2 = 0, jl = a.length; j2 < jl; j2++, k2++)
            r[k2] = a[j2];
        return r;
      }
      var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition"
      ];
      var defaults = {
        _disable: [],
        allowInput: false,
        allowInvalidPreload: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        autoFillDefaultTime: true,
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enableSeconds: false,
        enableTime: false,
        errorHandler: function(err) {
          return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function(givenDate) {
          var date = new Date(givenDate.getTime());
          date.setHours(0, 0, 0, 0);
          date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
          var week1 = new Date(date.getFullYear(), 0, 4);
          return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        monthSelectorType: "dropdown",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: void 0,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
      };
      var english = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21)
            return "th";
          switch (s % 10) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        monthAriaLabel: "Month",
        hourAriaLabel: "Hour",
        minuteAriaLabel: "Minute",
        time_24hr: false
      };
      var pad = function(number, length) {
        if (length === void 0) {
          length = 2;
        }
        return ("000" + number).slice(length * -1);
      };
      var int = function(bool) {
        return bool === true ? 1 : 0;
      };
      function debounce3(fn2, wait) {
        var t;
        return function() {
          var _this = this;
          clearTimeout(t);
          t = setTimeout(function() {
            return fn2.apply(_this, arguments);
          }, wait);
        };
      }
      var arrayify = function(obj) {
        return obj instanceof Array ? obj : [obj];
      };
      function toggleClass(elem, className, bool) {
        if (bool === true)
          return elem.classList.add(className);
        elem.classList.remove(className);
      }
      function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== void 0)
          e.textContent = content;
        return e;
      }
      function clearNode(node) {
        while (node.firstChild)
          node.removeChild(node.firstChild);
      }
      function findParent(node, condition) {
        if (condition(node))
          return node;
        else if (node.parentNode)
          return findParent(node.parentNode, condition);
        return void 0;
      }
      function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
          numInput.type = "number";
        } else {
          numInput.type = "text";
          numInput.pattern = "\\d*";
        }
        if (opts !== void 0)
          for (var key in opts)
            numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
      }
      function getEventTarget(event) {
        try {
          if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
          }
          return event.target;
        } catch (error) {
          return event.target;
        }
      }
      var doNothing = function() {
        return void 0;
      };
      var monthToStr = function(monthNumber, shorthand, locale) {
        return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
      };
      var revFormat = {
        D: doNothing,
        F: function(dateObj, monthName, locale) {
          dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function(dateObj, hour) {
          dateObj.setHours(parseFloat(hour));
        },
        H: function(dateObj, hour) {
          dateObj.setHours(parseFloat(hour));
        },
        J: function(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        K: function(dateObj, amPM, locale) {
          dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function(dateObj, shortMonth, locale) {
          dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function(dateObj, seconds) {
          dateObj.setSeconds(parseFloat(seconds));
        },
        U: function(_2, unixSeconds) {
          return new Date(parseFloat(unixSeconds) * 1e3);
        },
        W: function(dateObj, weekNum, locale) {
          var weekNumber = parseInt(weekNum);
          var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
          date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
          return date;
        },
        Y: function(dateObj, year) {
          dateObj.setFullYear(parseFloat(year));
        },
        Z: function(_2, ISODate) {
          return new Date(ISODate);
        },
        d: function(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        h: function(dateObj, hour) {
          dateObj.setHours(parseFloat(hour));
        },
        i: function(dateObj, minutes) {
          dateObj.setMinutes(parseFloat(minutes));
        },
        j: function(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        l: doNothing,
        m: function(dateObj, month) {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function(dateObj, month) {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function(dateObj, seconds) {
          dateObj.setSeconds(parseFloat(seconds));
        },
        u: function(_2, unixMillSeconds) {
          return new Date(parseFloat(unixMillSeconds));
        },
        w: doNothing,
        y: function(dateObj, year) {
          dateObj.setFullYear(2e3 + parseFloat(year));
        }
      };
      var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
      };
      var formats = {
        Z: function(date) {
          return date.toISOString();
        },
        D: function(date, locale, options) {
          return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        F: function(date, locale, options) {
          return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        G: function(date, locale, options) {
          return pad(formats.h(date, locale, options));
        },
        H: function(date) {
          return pad(date.getHours());
        },
        J: function(date, locale) {
          return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
        },
        K: function(date, locale) {
          return locale.amPM[int(date.getHours() > 11)];
        },
        M: function(date, locale) {
          return monthToStr(date.getMonth(), true, locale);
        },
        S: function(date) {
          return pad(date.getSeconds());
        },
        U: function(date) {
          return date.getTime() / 1e3;
        },
        W: function(date, _2, options) {
          return options.getWeek(date);
        },
        Y: function(date) {
          return pad(date.getFullYear(), 4);
        },
        d: function(date) {
          return pad(date.getDate());
        },
        h: function(date) {
          return date.getHours() % 12 ? date.getHours() % 12 : 12;
        },
        i: function(date) {
          return pad(date.getMinutes());
        },
        j: function(date) {
          return date.getDate();
        },
        l: function(date, locale) {
          return locale.weekdays.longhand[date.getDay()];
        },
        m: function(date) {
          return pad(date.getMonth() + 1);
        },
        n: function(date) {
          return date.getMonth() + 1;
        },
        s: function(date) {
          return date.getSeconds();
        },
        u: function(date) {
          return date.getTime();
        },
        w: function(date) {
          return date.getDay();
        },
        y: function(date) {
          return String(date.getFullYear()).substring(2);
        }
      };
      var createDateFormatter = function(_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
        return function(dateObj, frmt, overrideLocale) {
          var locale = overrideLocale || l10n;
          if (config.formatDate !== void 0 && !isMobile) {
            return config.formatDate(dateObj, frmt, locale);
          }
          return frmt.split("").map(function(c, i, arr) {
            return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
          }).join("");
        };
      };
      var createDateParser = function(_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function(date, givenFormat, timeless, customLocale) {
          if (date !== 0 && !date)
            return void 0;
          var locale = customLocale || l10n;
          var parsedDate;
          var dateOrig = date;
          if (date instanceof Date)
            parsedDate = new Date(date.getTime());
          else if (typeof date !== "string" && date.toFixed !== void 0)
            parsedDate = new Date(date);
          else if (typeof date === "string") {
            var format2 = givenFormat || (config || defaults).dateFormat;
            var datestr = String(date).trim();
            if (datestr === "today") {
              parsedDate = new Date();
              timeless = true;
            } else if (/Z$/.test(datestr) || /GMT$/.test(datestr))
              parsedDate = new Date(date);
            else if (config && config.parseDate)
              parsedDate = config.parseDate(date, format2);
            else {
              parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
              var matched = void 0, ops = [];
              for (var i = 0, matchIndex = 0, regexStr = ""; i < format2.length; i++) {
                var token_1 = format2[i];
                var isBackSlash = token_1 === "\\";
                var escaped = format2[i - 1] === "\\" || isBackSlash;
                if (tokenRegex[token_1] && !escaped) {
                  regexStr += tokenRegex[token_1];
                  var match = new RegExp(regexStr).exec(date);
                  if (match && (matched = true)) {
                    ops[token_1 !== "Y" ? "push" : "unshift"]({
                      fn: revFormat[token_1],
                      val: match[++matchIndex]
                    });
                  }
                } else if (!isBackSlash)
                  regexStr += ".";
                ops.forEach(function(_a2) {
                  var fn2 = _a2.fn, val = _a2.val;
                  return parsedDate = fn2(parsedDate, val, locale) || parsedDate;
                });
              }
              parsedDate = matched ? parsedDate : void 0;
            }
          }
          if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
            config.errorHandler(new Error("Invalid date provided: " + dateOrig));
            return void 0;
          }
          if (timeless === true)
            parsedDate.setHours(0, 0, 0, 0);
          return parsedDate;
        };
      };
      function compareDates(date1, date2, timeless) {
        if (timeless === void 0) {
          timeless = true;
        }
        if (timeless !== false) {
          return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
        }
        return date1.getTime() - date2.getTime();
      }
      var isBetween = function(ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
      };
      var duration = {
        DAY: 864e5
      };
      function getDefaultHours(config) {
        var hours = config.defaultHour;
        var minutes = config.defaultMinute;
        var seconds = config.defaultSeconds;
        if (config.minDate !== void 0) {
          var minHour = config.minDate.getHours();
          var minMinutes = config.minDate.getMinutes();
          var minSeconds = config.minDate.getSeconds();
          if (hours < minHour) {
            hours = minHour;
          }
          if (hours === minHour && minutes < minMinutes) {
            minutes = minMinutes;
          }
          if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
            seconds = config.minDate.getSeconds();
        }
        if (config.maxDate !== void 0) {
          var maxHr = config.maxDate.getHours();
          var maxMinutes = config.maxDate.getMinutes();
          hours = Math.min(hours, maxHr);
          if (hours === maxHr)
            minutes = Math.min(maxMinutes, minutes);
          if (hours === maxHr && minutes === maxMinutes)
            seconds = config.maxDate.getSeconds();
        }
        return { hours, minutes, seconds };
      }
      if (typeof Object.assign !== "function") {
        Object.assign = function(target) {
          var args = [];
          for (var _i2 = 1; _i2 < arguments.length; _i2++) {
            args[_i2 - 1] = arguments[_i2];
          }
          if (!target) {
            throw TypeError("Cannot convert undefined or null to object");
          }
          var _loop_1 = function(source2) {
            if (source2) {
              Object.keys(source2).forEach(function(key) {
                return target[key] = source2[key];
              });
            }
          };
          for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var source = args_1[_a];
            _loop_1(source);
          }
          return target;
        };
      }
      var DEBOUNCED_CHANGE_MS = 300;
      function FlatpickrInstance(element, instanceConfig) {
        var self2 = {
          config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
          l10n: english
        };
        self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
        self2._handlers = [];
        self2.pluginElements = [];
        self2.loadedPlugins = [];
        self2._bind = bind;
        self2._setHoursFromDate = setHoursFromDate;
        self2._positionCalendar = positionCalendar;
        self2.changeMonth = changeMonth;
        self2.changeYear = changeYear;
        self2.clear = clear;
        self2.close = close;
        self2._createElement = createElement;
        self2.destroy = destroy;
        self2.isEnabled = isEnabled;
        self2.jumpToDate = jumpToDate;
        self2.open = open;
        self2.redraw = redraw;
        self2.set = set;
        self2.setDate = setDate;
        self2.toggle = toggle;
        function setupHelperFunctions() {
          self2.utils = {
            getDaysInMonth: function(month, yr2) {
              if (month === void 0) {
                month = self2.currentMonth;
              }
              if (yr2 === void 0) {
                yr2 = self2.currentYear;
              }
              if (month === 1 && (yr2 % 4 === 0 && yr2 % 100 !== 0 || yr2 % 400 === 0))
                return 29;
              return self2.l10n.daysInMonth[month];
            }
          };
        }
        function init() {
          self2.element = self2.input = element;
          self2.isOpen = false;
          parseConfig();
          setupLocale();
          setupInputs();
          setupDates();
          setupHelperFunctions();
          if (!self2.isMobile)
            build();
          bindEvents();
          if (self2.selectedDates.length || self2.config.noCalendar) {
            if (self2.config.enableTime) {
              setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
            }
            updateValue(false);
          }
          setCalendarWidth();
          var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          if (!self2.isMobile && isSafari) {
            positionCalendar();
          }
          triggerEvent("onReady");
        }
        function bindToInstance(fn2) {
          return fn2.bind(self2);
        }
        function setCalendarWidth() {
          var config = self2.config;
          if (config.weekNumbers === false && config.showMonths === 1) {
            return;
          } else if (config.noCalendar !== true) {
            window.requestAnimationFrame(function() {
              if (self2.calendarContainer !== void 0) {
                self2.calendarContainer.style.visibility = "hidden";
                self2.calendarContainer.style.display = "block";
              }
              if (self2.daysContainer !== void 0) {
                var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
                self2.daysContainer.style.width = daysWidth + "px";
                self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
                self2.calendarContainer.style.removeProperty("visibility");
                self2.calendarContainer.style.removeProperty("display");
              }
            });
          }
        }
        function updateTime(e) {
          if (self2.selectedDates.length === 0) {
            var defaultDate = self2.config.minDate === void 0 || compareDates(new Date(), self2.config.minDate) >= 0 ? new Date() : new Date(self2.config.minDate.getTime());
            var defaults2 = getDefaultHours(self2.config);
            defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
            self2.selectedDates = [defaultDate];
            self2.latestSelectedDateObj = defaultDate;
          }
          if (e !== void 0 && e.type !== "blur") {
            timeWrapper(e);
          }
          var prevValue = self2._input.value;
          setHoursFromInputs();
          updateValue();
          if (self2._input.value !== prevValue) {
            self2._debouncedChange();
          }
        }
        function ampm2military(hour, amPM) {
          return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
        }
        function military2ampm(hour) {
          switch (hour % 24) {
            case 0:
            case 12:
              return 12;
            default:
              return hour % 12;
          }
        }
        function setHoursFromInputs() {
          if (self2.hourElement === void 0 || self2.minuteElement === void 0)
            return;
          var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
          if (self2.amPM !== void 0) {
            hours = ampm2military(hours, self2.amPM.textContent);
          }
          var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
          var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
          if (limitMaxHours) {
            var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
            hours = Math.min(hours, maxTime.getHours());
            if (hours === maxTime.getHours())
              minutes = Math.min(minutes, maxTime.getMinutes());
            if (minutes === maxTime.getMinutes())
              seconds = Math.min(seconds, maxTime.getSeconds());
          }
          if (limitMinHours) {
            var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
            hours = Math.max(hours, minTime.getHours());
            if (hours === minTime.getHours() && minutes < minTime.getMinutes())
              minutes = minTime.getMinutes();
            if (minutes === minTime.getMinutes())
              seconds = Math.max(seconds, minTime.getSeconds());
          }
          setHours(hours, minutes, seconds);
        }
        function setHoursFromDate(dateObj) {
          var date = dateObj || self2.latestSelectedDateObj;
          if (date) {
            setHours(date.getHours(), date.getMinutes(), date.getSeconds());
          }
        }
        function setHours(hours, minutes, seconds) {
          if (self2.latestSelectedDateObj !== void 0) {
            self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
          }
          if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
            return;
          self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
          self2.minuteElement.value = pad(minutes);
          if (self2.amPM !== void 0)
            self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
          if (self2.secondElement !== void 0)
            self2.secondElement.value = pad(seconds);
        }
        function onYearInput(event) {
          var eventTarget = getEventTarget(event);
          var year = parseInt(eventTarget.value) + (event.delta || 0);
          if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
            changeYear(year);
          }
        }
        function bind(element2, event, handler, options) {
          if (event instanceof Array)
            return event.forEach(function(ev) {
              return bind(element2, ev, handler, options);
            });
          if (element2 instanceof Array)
            return element2.forEach(function(el2) {
              return bind(el2, event, handler, options);
            });
          element2.addEventListener(event, handler, options);
          self2._handlers.push({
            remove: function() {
              return element2.removeEventListener(event, handler);
            }
          });
        }
        function triggerChange() {
          triggerEvent("onChange");
        }
        function bindEvents() {
          if (self2.config.wrap) {
            ["open", "close", "toggle", "clear"].forEach(function(evt) {
              Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el2) {
                return bind(el2, "click", self2[evt]);
              });
            });
          }
          if (self2.isMobile) {
            setupMobile();
            return;
          }
          var debouncedResize = debounce3(onResize, 50);
          self2._debouncedChange = debounce3(triggerChange, DEBOUNCED_CHANGE_MS);
          if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
            bind(self2.daysContainer, "mouseover", function(e) {
              if (self2.config.mode === "range")
                onMouseOver(getEventTarget(e));
            });
          bind(window.document.body, "keydown", onKeyDown);
          if (!self2.config.inline && !self2.config.static)
            bind(window, "resize", debouncedResize);
          if (window.ontouchstart !== void 0)
            bind(window.document, "touchstart", documentClick);
          else
            bind(window.document, "mousedown", documentClick);
          bind(window.document, "focus", documentClick, { capture: true });
          if (self2.config.clickOpens === true) {
            bind(self2._input, "focus", self2.open);
            bind(self2._input, "click", self2.open);
          }
          if (self2.daysContainer !== void 0) {
            bind(self2.monthNav, "click", onMonthNavClick);
            bind(self2.monthNav, ["keyup", "increment"], onYearInput);
            bind(self2.daysContainer, "click", selectDate);
          }
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
            var selText = function(e) {
              return getEventTarget(e).select();
            };
            bind(self2.timeContainer, ["increment"], updateTime);
            bind(self2.timeContainer, "blur", updateTime, { capture: true });
            bind(self2.timeContainer, "click", timeIncrement);
            bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
            if (self2.secondElement !== void 0)
              bind(self2.secondElement, "focus", function() {
                return self2.secondElement && self2.secondElement.select();
              });
            if (self2.amPM !== void 0) {
              bind(self2.amPM, "click", function(e) {
                updateTime(e);
                triggerChange();
              });
            }
          }
          if (self2.config.allowInput) {
            bind(self2._input, "blur", onBlur);
          }
        }
        function jumpToDate(jumpDate, triggerChange2) {
          var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
          var oldYear = self2.currentYear;
          var oldMonth = self2.currentMonth;
          try {
            if (jumpTo !== void 0) {
              self2.currentYear = jumpTo.getFullYear();
              self2.currentMonth = jumpTo.getMonth();
            }
          } catch (e) {
            e.message = "Invalid date supplied: " + jumpTo;
            self2.config.errorHandler(e);
          }
          if (triggerChange2 && self2.currentYear !== oldYear) {
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
          if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
            triggerEvent("onMonthChange");
          }
          self2.redraw();
        }
        function timeIncrement(e) {
          var eventTarget = getEventTarget(e);
          if (~eventTarget.className.indexOf("arrow"))
            incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
        }
        function incrementNumInput(e, delta, inputElem) {
          var target = e && getEventTarget(e);
          var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
          var event = createEvent("increment");
          event.delta = delta;
          input && input.dispatchEvent(event);
        }
        function build() {
          var fragment = window.document.createDocumentFragment();
          self2.calendarContainer = createElement("div", "flatpickr-calendar");
          self2.calendarContainer.tabIndex = -1;
          if (!self2.config.noCalendar) {
            fragment.appendChild(buildMonthNav());
            self2.innerContainer = createElement("div", "flatpickr-innerContainer");
            if (self2.config.weekNumbers) {
              var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
              self2.innerContainer.appendChild(weekWrapper);
              self2.weekNumbers = weekNumbers;
              self2.weekWrapper = weekWrapper;
            }
            self2.rContainer = createElement("div", "flatpickr-rContainer");
            self2.rContainer.appendChild(buildWeekdays());
            if (!self2.daysContainer) {
              self2.daysContainer = createElement("div", "flatpickr-days");
              self2.daysContainer.tabIndex = -1;
            }
            buildDays();
            self2.rContainer.appendChild(self2.daysContainer);
            self2.innerContainer.appendChild(self2.rContainer);
            fragment.appendChild(self2.innerContainer);
          }
          if (self2.config.enableTime) {
            fragment.appendChild(buildTime());
          }
          toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
          toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
          toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
          self2.calendarContainer.appendChild(fragment);
          var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
          if (self2.config.inline || self2.config.static) {
            self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
            if (self2.config.inline) {
              if (!customAppend && self2.element.parentNode)
                self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
              else if (self2.config.appendTo !== void 0)
                self2.config.appendTo.appendChild(self2.calendarContainer);
            }
            if (self2.config.static) {
              var wrapper = createElement("div", "flatpickr-wrapper");
              if (self2.element.parentNode)
                self2.element.parentNode.insertBefore(wrapper, self2.element);
              wrapper.appendChild(self2.element);
              if (self2.altInput)
                wrapper.appendChild(self2.altInput);
              wrapper.appendChild(self2.calendarContainer);
            }
          }
          if (!self2.config.static && !self2.config.inline)
            (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
          var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
          dayElement.dateObj = date;
          dayElement.$i = i;
          dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
          if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
            self2.todayDateElem = dayElement;
            dayElement.classList.add("today");
            dayElement.setAttribute("aria-current", "date");
          }
          if (dateIsEnabled) {
            dayElement.tabIndex = -1;
            if (isDateSelected(date)) {
              dayElement.classList.add("selected");
              self2.selectedDateElem = dayElement;
              if (self2.config.mode === "range") {
                toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
                toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
                if (className === "nextMonthDay")
                  dayElement.classList.add("inRange");
              }
            }
          } else {
            dayElement.classList.add("flatpickr-disabled");
          }
          if (self2.config.mode === "range") {
            if (isDateInRange(date) && !isDateSelected(date))
              dayElement.classList.add("inRange");
          }
          if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
            self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
          }
          triggerEvent("onDayCreate", dayElement);
          return dayElement;
        }
        function focusOnDayElem(targetNode) {
          targetNode.focus();
          if (self2.config.mode === "range")
            onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
          var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
          var endMonth = delta > 0 ? self2.config.showMonths : -1;
          for (var m = startMonth; m != endMonth; m += delta) {
            var month = self2.daysContainer.children[m];
            var startIndex = delta > 0 ? 0 : month.children.length - 1;
            var endIndex = delta > 0 ? month.children.length : -1;
            for (var i = startIndex; i != endIndex; i += delta) {
              var c = month.children[i];
              if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                return c;
            }
          }
          return void 0;
        }
        function getNextAvailableDay(current, delta) {
          var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
          var endMonth = delta > 0 ? self2.config.showMonths : -1;
          var loopDelta = delta > 0 ? 1 : -1;
          for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
            var month = self2.daysContainer.children[m];
            var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
            var numMonthDays = month.children.length;
            for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
              var c = month.children[i];
              if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
                return focusOnDayElem(c);
            }
          }
          self2.changeMonth(loopDelta);
          focusOnDay(getFirstAvailableDay(loopDelta), 0);
          return void 0;
        }
        function focusOnDay(current, offset2) {
          var dayFocused = isInView(document.activeElement || document.body);
          var startElem = current !== void 0 ? current : dayFocused ? document.activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
          if (startElem === void 0) {
            self2._input.focus();
          } else if (!dayFocused) {
            focusOnDayElem(startElem);
          } else {
            getNextAvailableDay(startElem, offset2);
          }
        }
        function buildMonthDays(year, month) {
          var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
          var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
          var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
          var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
          for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
            days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
          }
          for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
            days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
          }
          for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
            days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
          }
          var dayContainer = createElement("div", "dayContainer");
          dayContainer.appendChild(days);
          return dayContainer;
        }
        function buildDays() {
          if (self2.daysContainer === void 0) {
            return;
          }
          clearNode(self2.daysContainer);
          if (self2.weekNumbers)
            clearNode(self2.weekNumbers);
          var frag = document.createDocumentFragment();
          for (var i = 0; i < self2.config.showMonths; i++) {
            var d = new Date(self2.currentYear, self2.currentMonth, 1);
            d.setMonth(self2.currentMonth + i);
            frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
          }
          self2.daysContainer.appendChild(frag);
          self2.days = self2.daysContainer.firstChild;
          if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
            onMouseOver();
          }
        }
        function buildMonthSwitch() {
          if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
            return;
          var shouldBuildMonth = function(month2) {
            if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
              return false;
            }
            return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
          };
          self2.monthsDropdownContainer.tabIndex = -1;
          self2.monthsDropdownContainer.innerHTML = "";
          for (var i = 0; i < 12; i++) {
            if (!shouldBuildMonth(i))
              continue;
            var month = createElement("option", "flatpickr-monthDropdown-month");
            month.value = new Date(self2.currentYear, i).getMonth().toString();
            month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
            month.tabIndex = -1;
            if (self2.currentMonth === i) {
              month.selected = true;
            }
            self2.monthsDropdownContainer.appendChild(month);
          }
        }
        function buildMonth() {
          var container = createElement("div", "flatpickr-month");
          var monthNavFragment = window.document.createDocumentFragment();
          var monthElement;
          if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
            monthElement = createElement("span", "cur-month");
          } else {
            self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
            self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
            bind(self2.monthsDropdownContainer, "change", function(e) {
              var target = getEventTarget(e);
              var selectedMonth = parseInt(target.value, 10);
              self2.changeMonth(selectedMonth - self2.currentMonth);
              triggerEvent("onMonthChange");
            });
            buildMonthSwitch();
            monthElement = self2.monthsDropdownContainer;
          }
          var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
          var yearElement = yearInput.getElementsByTagName("input")[0];
          yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
          if (self2.config.minDate) {
            yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
          }
          if (self2.config.maxDate) {
            yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
            yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
          }
          var currentMonth = createElement("div", "flatpickr-current-month");
          currentMonth.appendChild(monthElement);
          currentMonth.appendChild(yearInput);
          monthNavFragment.appendChild(currentMonth);
          container.appendChild(monthNavFragment);
          return {
            container,
            yearElement,
            monthElement
          };
        }
        function buildMonths() {
          clearNode(self2.monthNav);
          self2.monthNav.appendChild(self2.prevMonthNav);
          if (self2.config.showMonths) {
            self2.yearElements = [];
            self2.monthElements = [];
          }
          for (var m = self2.config.showMonths; m--; ) {
            var month = buildMonth();
            self2.yearElements.push(month.yearElement);
            self2.monthElements.push(month.monthElement);
            self2.monthNav.appendChild(month.container);
          }
          self2.monthNav.appendChild(self2.nextMonthNav);
        }
        function buildMonthNav() {
          self2.monthNav = createElement("div", "flatpickr-months");
          self2.yearElements = [];
          self2.monthElements = [];
          self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
          self2.prevMonthNav.innerHTML = self2.config.prevArrow;
          self2.nextMonthNav = createElement("span", "flatpickr-next-month");
          self2.nextMonthNav.innerHTML = self2.config.nextArrow;
          buildMonths();
          Object.defineProperty(self2, "_hidePrevMonthArrow", {
            get: function() {
              return self2.__hidePrevMonthArrow;
            },
            set: function(bool) {
              if (self2.__hidePrevMonthArrow !== bool) {
                toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
                self2.__hidePrevMonthArrow = bool;
              }
            }
          });
          Object.defineProperty(self2, "_hideNextMonthArrow", {
            get: function() {
              return self2.__hideNextMonthArrow;
            },
            set: function(bool) {
              if (self2.__hideNextMonthArrow !== bool) {
                toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
                self2.__hideNextMonthArrow = bool;
              }
            }
          });
          self2.currentYearElement = self2.yearElements[0];
          updateNavigationCurrentMonth();
          return self2.monthNav;
        }
        function buildTime() {
          self2.calendarContainer.classList.add("hasTime");
          if (self2.config.noCalendar)
            self2.calendarContainer.classList.add("noCalendar");
          var defaults2 = getDefaultHours(self2.config);
          self2.timeContainer = createElement("div", "flatpickr-time");
          self2.timeContainer.tabIndex = -1;
          var separator = createElement("span", "flatpickr-time-separator", ":");
          var hourInput = createNumberInput("flatpickr-hour", {
            "aria-label": self2.l10n.hourAriaLabel
          });
          self2.hourElement = hourInput.getElementsByTagName("input")[0];
          var minuteInput = createNumberInput("flatpickr-minute", {
            "aria-label": self2.l10n.minuteAriaLabel
          });
          self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
          self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
          self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
          self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
          self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
          self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
          self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
          self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
          self2.hourElement.setAttribute("maxlength", "2");
          self2.minuteElement.setAttribute("min", "0");
          self2.minuteElement.setAttribute("max", "59");
          self2.minuteElement.setAttribute("maxlength", "2");
          self2.timeContainer.appendChild(hourInput);
          self2.timeContainer.appendChild(separator);
          self2.timeContainer.appendChild(minuteInput);
          if (self2.config.time_24hr)
            self2.timeContainer.classList.add("time24hr");
          if (self2.config.enableSeconds) {
            self2.timeContainer.classList.add("hasSeconds");
            var secondInput = createNumberInput("flatpickr-second");
            self2.secondElement = secondInput.getElementsByTagName("input")[0];
            self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
            self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
            self2.secondElement.setAttribute("min", "0");
            self2.secondElement.setAttribute("max", "59");
            self2.secondElement.setAttribute("maxlength", "2");
            self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
            self2.timeContainer.appendChild(secondInput);
          }
          if (!self2.config.time_24hr) {
            self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
            self2.amPM.title = self2.l10n.toggleTitle;
            self2.amPM.tabIndex = -1;
            self2.timeContainer.appendChild(self2.amPM);
          }
          return self2.timeContainer;
        }
        function buildWeekdays() {
          if (!self2.weekdayContainer)
            self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
          else
            clearNode(self2.weekdayContainer);
          for (var i = self2.config.showMonths; i--; ) {
            var container = createElement("div", "flatpickr-weekdaycontainer");
            self2.weekdayContainer.appendChild(container);
          }
          updateWeekdays();
          return self2.weekdayContainer;
        }
        function updateWeekdays() {
          if (!self2.weekdayContainer) {
            return;
          }
          var firstDayOfWeek = self2.l10n.firstDayOfWeek;
          var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
          if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
            weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
          }
          for (var i = self2.config.showMonths; i--; ) {
            self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
          }
        }
        function buildWeeks() {
          self2.calendarContainer.classList.add("hasWeeks");
          var weekWrapper = createElement("div", "flatpickr-weekwrapper");
          weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
          var weekNumbers = createElement("div", "flatpickr-weeks");
          weekWrapper.appendChild(weekNumbers);
          return {
            weekWrapper,
            weekNumbers
          };
        }
        function changeMonth(value, isOffset) {
          if (isOffset === void 0) {
            isOffset = true;
          }
          var delta = isOffset ? value : value - self2.currentMonth;
          if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
            return;
          self2.currentMonth += delta;
          if (self2.currentMonth < 0 || self2.currentMonth > 11) {
            self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
            self2.currentMonth = (self2.currentMonth + 12) % 12;
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
          buildDays();
          triggerEvent("onMonthChange");
          updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
          if (triggerChangeEvent === void 0) {
            triggerChangeEvent = true;
          }
          if (toInitial === void 0) {
            toInitial = true;
          }
          self2.input.value = "";
          if (self2.altInput !== void 0)
            self2.altInput.value = "";
          if (self2.mobileInput !== void 0)
            self2.mobileInput.value = "";
          self2.selectedDates = [];
          self2.latestSelectedDateObj = void 0;
          if (toInitial === true) {
            self2.currentYear = self2._initialDate.getFullYear();
            self2.currentMonth = self2._initialDate.getMonth();
          }
          if (self2.config.enableTime === true) {
            var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
            setHours(hours, minutes, seconds);
          }
          self2.redraw();
          if (triggerChangeEvent)
            triggerEvent("onChange");
        }
        function close() {
          self2.isOpen = false;
          if (!self2.isMobile) {
            if (self2.calendarContainer !== void 0) {
              self2.calendarContainer.classList.remove("open");
            }
            if (self2._input !== void 0) {
              self2._input.classList.remove("active");
            }
          }
          triggerEvent("onClose");
        }
        function destroy() {
          if (self2.config !== void 0)
            triggerEvent("onDestroy");
          for (var i = self2._handlers.length; i--; ) {
            self2._handlers[i].remove();
          }
          self2._handlers = [];
          if (self2.mobileInput) {
            if (self2.mobileInput.parentNode)
              self2.mobileInput.parentNode.removeChild(self2.mobileInput);
            self2.mobileInput = void 0;
          } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
            if (self2.config.static && self2.calendarContainer.parentNode) {
              var wrapper = self2.calendarContainer.parentNode;
              wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
              if (wrapper.parentNode) {
                while (wrapper.firstChild)
                  wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                wrapper.parentNode.removeChild(wrapper);
              }
            } else
              self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
          }
          if (self2.altInput) {
            self2.input.type = "text";
            if (self2.altInput.parentNode)
              self2.altInput.parentNode.removeChild(self2.altInput);
            delete self2.altInput;
          }
          if (self2.input) {
            self2.input.type = self2.input._type;
            self2.input.classList.remove("flatpickr-input");
            self2.input.removeAttribute("readonly");
          }
          [
            "_showTimeInput",
            "latestSelectedDateObj",
            "_hideNextMonthArrow",
            "_hidePrevMonthArrow",
            "__hideNextMonthArrow",
            "__hidePrevMonthArrow",
            "isMobile",
            "isOpen",
            "selectedDateElem",
            "minDateHasTime",
            "maxDateHasTime",
            "days",
            "daysContainer",
            "_input",
            "_positionElement",
            "innerContainer",
            "rContainer",
            "monthNav",
            "todayDateElem",
            "calendarContainer",
            "weekdayContainer",
            "prevMonthNav",
            "nextMonthNav",
            "monthsDropdownContainer",
            "currentMonthElement",
            "currentYearElement",
            "navigationCurrentMonth",
            "selectedDateElem",
            "config"
          ].forEach(function(k2) {
            try {
              delete self2[k2];
            } catch (_2) {
            }
          });
        }
        function isCalendarElem(elem) {
          if (self2.config.appendTo && self2.config.appendTo.contains(elem))
            return true;
          return self2.calendarContainer.contains(elem);
        }
        function documentClick(e) {
          if (self2.isOpen && !self2.config.inline) {
            var eventTarget_1 = getEventTarget(e);
            var isCalendarElement = isCalendarElem(eventTarget_1);
            var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self2.input) || ~e.path.indexOf(self2.altInput));
            var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
            var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
              return elem.contains(eventTarget_1);
            });
            if (lostFocus && isIgnored) {
              if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
                updateTime();
              }
              self2.close();
              if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1) {
                self2.clear(false);
                self2.redraw();
              }
            }
          }
        }
        function changeYear(newYear) {
          if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
            return;
          var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
          self2.currentYear = newYearNum || self2.currentYear;
          if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
            self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
          } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
            self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
          }
          if (isNewYear) {
            self2.redraw();
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
        }
        function isEnabled(date, timeless) {
          var _a;
          if (timeless === void 0) {
            timeless = true;
          }
          var dateToCheck = self2.parseDate(date, void 0, timeless);
          if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
            return false;
          if (!self2.config.enable && self2.config.disable.length === 0)
            return true;
          if (dateToCheck === void 0)
            return false;
          var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
          for (var i = 0, d = void 0; i < array.length; i++) {
            d = array[i];
            if (typeof d === "function" && d(dateToCheck))
              return bool;
            else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
              return bool;
            else if (typeof d === "string") {
              var parsed = self2.parseDate(d, void 0, true);
              return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
            } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
              return bool;
          }
          return !bool;
        }
        function isInView(elem) {
          if (self2.daysContainer !== void 0)
            return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
          return false;
        }
        function onBlur(e) {
          var isInput = e.target === self2._input;
          if (isInput && (self2.selectedDates.length > 0 || self2._input.value.length > 0) && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
            self2.setDate(self2._input.value, true, e.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          }
        }
        function onKeyDown(e) {
          var eventTarget = getEventTarget(e);
          var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
          var allowInput = self2.config.allowInput;
          var allowKeydown = self2.isOpen && (!allowInput || !isInput);
          var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
          if (e.keyCode === 13 && isInput) {
            if (allowInput) {
              self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
              return eventTarget.blur();
            } else {
              self2.open();
            }
          } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
            var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
            switch (e.keyCode) {
              case 13:
                if (isTimeObj) {
                  e.preventDefault();
                  updateTime();
                  focusAndClose();
                } else
                  selectDate(e);
                break;
              case 27:
                e.preventDefault();
                focusAndClose();
                break;
              case 8:
              case 46:
                if (isInput && !self2.config.allowInput) {
                  e.preventDefault();
                  self2.clear();
                }
                break;
              case 37:
              case 39:
                if (!isTimeObj && !isInput) {
                  e.preventDefault();
                  if (self2.daysContainer !== void 0 && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
                    var delta_1 = e.keyCode === 39 ? 1 : -1;
                    if (!e.ctrlKey)
                      focusOnDay(void 0, delta_1);
                    else {
                      e.stopPropagation();
                      changeMonth(delta_1);
                      focusOnDay(getFirstAvailableDay(1), 0);
                    }
                  }
                } else if (self2.hourElement)
                  self2.hourElement.focus();
                break;
              case 38:
              case 40:
                e.preventDefault();
                var delta = e.keyCode === 40 ? 1 : -1;
                if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
                  if (e.ctrlKey) {
                    e.stopPropagation();
                    changeYear(self2.currentYear - delta);
                    focusOnDay(getFirstAvailableDay(1), 0);
                  } else if (!isTimeObj)
                    focusOnDay(void 0, delta * 7);
                } else if (eventTarget === self2.currentYearElement) {
                  changeYear(self2.currentYear - delta);
                } else if (self2.config.enableTime) {
                  if (!isTimeObj && self2.hourElement)
                    self2.hourElement.focus();
                  updateTime(e);
                  self2._debouncedChange();
                }
                break;
              case 9:
                if (isTimeObj) {
                  var elems = [
                    self2.hourElement,
                    self2.minuteElement,
                    self2.secondElement,
                    self2.amPM
                  ].concat(self2.pluginElements).filter(function(x2) {
                    return x2;
                  });
                  var i = elems.indexOf(eventTarget);
                  if (i !== -1) {
                    var target = elems[i + (e.shiftKey ? -1 : 1)];
                    e.preventDefault();
                    (target || self2._input).focus();
                  }
                } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e.shiftKey) {
                  e.preventDefault();
                  self2._input.focus();
                }
                break;
            }
          }
          if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
            switch (e.key) {
              case self2.l10n.amPM[0].charAt(0):
              case self2.l10n.amPM[0].charAt(0).toLowerCase():
                self2.amPM.textContent = self2.l10n.amPM[0];
                setHoursFromInputs();
                updateValue();
                break;
              case self2.l10n.amPM[1].charAt(0):
              case self2.l10n.amPM[1].charAt(0).toLowerCase():
                self2.amPM.textContent = self2.l10n.amPM[1];
                setHoursFromInputs();
                updateValue();
                break;
            }
          }
          if (isInput || isCalendarElem(eventTarget)) {
            triggerEvent("onKeyDown", e);
          }
        }
        function onMouseOver(elem) {
          if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled")))
            return;
          var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
          var containsDisabled = false;
          var minRange = 0, maxRange = 0;
          for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
            if (!isEnabled(new Date(t), true)) {
              containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
              if (t < initialDate && (!minRange || t > minRange))
                minRange = t;
              else if (t > initialDate && (!maxRange || t < maxRange))
                maxRange = t;
            }
          }
          for (var m = 0; m < self2.config.showMonths; m++) {
            var month = self2.daysContainer.children[m];
            var _loop_1 = function(i2, l2) {
              var dayElem = month.children[i2], date = dayElem.dateObj;
              var timestamp = date.getTime();
              var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
              if (outOfRange) {
                dayElem.classList.add("notAllowed");
                ["inRange", "startRange", "endRange"].forEach(function(c) {
                  dayElem.classList.remove(c);
                });
                return "continue";
              } else if (containsDisabled && !outOfRange)
                return "continue";
              ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
                dayElem.classList.remove(c);
              });
              if (elem !== void 0) {
                elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
                if (initialDate < hoverDate && timestamp === initialDate)
                  dayElem.classList.add("startRange");
                else if (initialDate > hoverDate && timestamp === initialDate)
                  dayElem.classList.add("endRange");
                if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
                  dayElem.classList.add("inRange");
              }
            };
            for (var i = 0, l = month.children.length; i < l; i++) {
              _loop_1(i, l);
            }
          }
        }
        function onResize() {
          if (self2.isOpen && !self2.config.static && !self2.config.inline)
            positionCalendar();
        }
        function open(e, positionElement) {
          if (positionElement === void 0) {
            positionElement = self2._positionElement;
          }
          if (self2.isMobile === true) {
            if (e) {
              e.preventDefault();
              var eventTarget = getEventTarget(e);
              if (eventTarget) {
                eventTarget.blur();
              }
            }
            if (self2.mobileInput !== void 0) {
              self2.mobileInput.focus();
              self2.mobileInput.click();
            }
            triggerEvent("onOpen");
            return;
          } else if (self2._input.disabled || self2.config.inline) {
            return;
          }
          var wasOpen = self2.isOpen;
          self2.isOpen = true;
          if (!wasOpen) {
            self2.calendarContainer.classList.add("open");
            self2._input.classList.add("active");
            triggerEvent("onOpen");
            positionCalendar(positionElement);
          }
          if (self2.config.enableTime === true && self2.config.noCalendar === true) {
            if (self2.config.allowInput === false && (e === void 0 || !self2.timeContainer.contains(e.relatedTarget))) {
              setTimeout(function() {
                return self2.hourElement.select();
              }, 50);
            }
          }
        }
        function minMaxDateSetter(type) {
          return function(date) {
            var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
            var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
            if (dateObj !== void 0) {
              self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
            }
            if (self2.selectedDates) {
              self2.selectedDates = self2.selectedDates.filter(function(d) {
                return isEnabled(d);
              });
              if (!self2.selectedDates.length && type === "min")
                setHoursFromDate(dateObj);
              updateValue();
            }
            if (self2.daysContainer) {
              redraw();
              if (dateObj !== void 0)
                self2.currentYearElement[type] = dateObj.getFullYear().toString();
              else
                self2.currentYearElement.removeAttribute(type);
              self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
            }
          };
        }
        function parseConfig() {
          var boolOpts = [
            "wrap",
            "weekNumbers",
            "allowInput",
            "allowInvalidPreload",
            "clickOpens",
            "time_24hr",
            "enableTime",
            "noCalendar",
            "altInput",
            "shorthandCurrentMonth",
            "inline",
            "static",
            "enableSeconds",
            "disableMobile"
          ];
          var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
          var formats2 = {};
          self2.config.parseDate = userConfig.parseDate;
          self2.config.formatDate = userConfig.formatDate;
          Object.defineProperty(self2.config, "enable", {
            get: function() {
              return self2.config._enable;
            },
            set: function(dates) {
              self2.config._enable = parseDateRules(dates);
            }
          });
          Object.defineProperty(self2.config, "disable", {
            get: function() {
              return self2.config._disable;
            },
            set: function(dates) {
              self2.config._disable = parseDateRules(dates);
            }
          });
          var timeMode = userConfig.mode === "time";
          if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
            var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
            formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
          }
          if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
            var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
            formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
          }
          Object.defineProperty(self2.config, "minDate", {
            get: function() {
              return self2.config._minDate;
            },
            set: minMaxDateSetter("min")
          });
          Object.defineProperty(self2.config, "maxDate", {
            get: function() {
              return self2.config._maxDate;
            },
            set: minMaxDateSetter("max")
          });
          var minMaxTimeSetter = function(type) {
            return function(val) {
              self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
            };
          };
          Object.defineProperty(self2.config, "minTime", {
            get: function() {
              return self2.config._minTime;
            },
            set: minMaxTimeSetter("min")
          });
          Object.defineProperty(self2.config, "maxTime", {
            get: function() {
              return self2.config._maxTime;
            },
            set: minMaxTimeSetter("max")
          });
          if (userConfig.mode === "time") {
            self2.config.noCalendar = true;
            self2.config.enableTime = true;
          }
          Object.assign(self2.config, formats2, userConfig);
          for (var i = 0; i < boolOpts.length; i++)
            self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
          HOOKS.filter(function(hook) {
            return self2.config[hook] !== void 0;
          }).forEach(function(hook) {
            self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
          });
          self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          for (var i = 0; i < self2.config.plugins.length; i++) {
            var pluginConf = self2.config.plugins[i](self2) || {};
            for (var key in pluginConf) {
              if (HOOKS.indexOf(key) > -1) {
                self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
              } else if (typeof userConfig[key] === "undefined")
                self2.config[key] = pluginConf[key];
            }
          }
          if (!userConfig.altInputClass) {
            self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
          }
          triggerEvent("onParseConfig");
        }
        function getInputElem() {
          return self2.config.wrap ? element.querySelector("[data-input]") : element;
        }
        function setupLocale() {
          if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
            self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
          self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
          tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
          var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
          if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
            self2.config.time_24hr = self2.l10n.time_24hr;
          }
          self2.formatDate = createDateFormatter(self2);
          self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
        }
        function positionCalendar(customPositionElement) {
          if (typeof self2.config.position === "function") {
            return void self2.config.position(self2, customPositionElement);
          }
          if (self2.calendarContainer === void 0)
            return;
          triggerEvent("onPreCalendarPosition");
          var positionElement = customPositionElement || self2._positionElement;
          var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
            return acc + child.offsetHeight;
          }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
          var top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
          toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
          toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
          if (self2.config.inline)
            return;
          var left2 = window.pageXOffset + inputBounds.left;
          var isCenter = false;
          var isRight = false;
          if (configPosHorizontal === "center") {
            left2 -= (calendarWidth - inputBounds.width) / 2;
            isCenter = true;
          } else if (configPosHorizontal === "right") {
            left2 -= calendarWidth - inputBounds.width;
            isRight = true;
          }
          toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
          toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
          toggleClass(self2.calendarContainer, "arrowRight", isRight);
          var right2 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
          var rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
          var centerMost = right2 + calendarWidth > window.document.body.offsetWidth;
          toggleClass(self2.calendarContainer, "rightMost", rightMost);
          if (self2.config.static)
            return;
          self2.calendarContainer.style.top = top2 + "px";
          if (!rightMost) {
            self2.calendarContainer.style.left = left2 + "px";
            self2.calendarContainer.style.right = "auto";
          } else if (!centerMost) {
            self2.calendarContainer.style.left = "auto";
            self2.calendarContainer.style.right = right2 + "px";
          } else {
            var doc = getDocumentStyleSheet();
            if (doc === void 0)
              return;
            var bodyWidth = window.document.body.offsetWidth;
            var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
            var centerBefore = ".flatpickr-calendar.centerMost:before";
            var centerAfter = ".flatpickr-calendar.centerMost:after";
            var centerIndex = doc.cssRules.length;
            var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
            toggleClass(self2.calendarContainer, "rightMost", false);
            toggleClass(self2.calendarContainer, "centerMost", true);
            doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
            self2.calendarContainer.style.left = centerLeft + "px";
            self2.calendarContainer.style.right = "auto";
          }
        }
        function getDocumentStyleSheet() {
          var editableSheet = null;
          for (var i = 0; i < document.styleSheets.length; i++) {
            var sheet = document.styleSheets[i];
            try {
              sheet.cssRules;
            } catch (err) {
              continue;
            }
            editableSheet = sheet;
            break;
          }
          return editableSheet != null ? editableSheet : createStyleSheet();
        }
        function createStyleSheet() {
          var style = document.createElement("style");
          document.head.appendChild(style);
          return style.sheet;
        }
        function redraw() {
          if (self2.config.noCalendar || self2.isMobile)
            return;
          buildMonthSwitch();
          updateNavigationCurrentMonth();
          buildDays();
        }
        function focusAndClose() {
          self2._input.focus();
          if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
            setTimeout(self2.close, 0);
          } else {
            self2.close();
          }
        }
        function selectDate(e) {
          e.preventDefault();
          e.stopPropagation();
          var isSelectable = function(day) {
            return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
          };
          var t = findParent(getEventTarget(e), isSelectable);
          if (t === void 0)
            return;
          var target = t;
          var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
          var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
          self2.selectedDateElem = target;
          if (self2.config.mode === "single")
            self2.selectedDates = [selectedDate];
          else if (self2.config.mode === "multiple") {
            var selectedIndex = isDateSelected(selectedDate);
            if (selectedIndex)
              self2.selectedDates.splice(parseInt(selectedIndex), 1);
            else
              self2.selectedDates.push(selectedDate);
          } else if (self2.config.mode === "range") {
            if (self2.selectedDates.length === 2) {
              self2.clear(false, false);
            }
            self2.latestSelectedDateObj = selectedDate;
            self2.selectedDates.push(selectedDate);
            if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
              self2.selectedDates.sort(function(a, b) {
                return a.getTime() - b.getTime();
              });
          }
          setHoursFromInputs();
          if (shouldChangeMonth) {
            var isNewYear = self2.currentYear !== selectedDate.getFullYear();
            self2.currentYear = selectedDate.getFullYear();
            self2.currentMonth = selectedDate.getMonth();
            if (isNewYear) {
              triggerEvent("onYearChange");
              buildMonthSwitch();
            }
            triggerEvent("onMonthChange");
          }
          updateNavigationCurrentMonth();
          buildDays();
          updateValue();
          if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
            focusOnDayElem(target);
          else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
            self2.selectedDateElem && self2.selectedDateElem.focus();
          }
          if (self2.hourElement !== void 0)
            self2.hourElement !== void 0 && self2.hourElement.focus();
          if (self2.config.closeOnSelect) {
            var single = self2.config.mode === "single" && !self2.config.enableTime;
            var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
            if (single || range) {
              focusAndClose();
            }
          }
          triggerChange();
        }
        var CALLBACKS = {
          locale: [setupLocale, updateWeekdays],
          showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
          minDate: [jumpToDate],
          maxDate: [jumpToDate],
          clickOpens: [
            function() {
              if (self2.config.clickOpens === true) {
                bind(self2._input, "focus", self2.open);
                bind(self2._input, "click", self2.open);
              } else {
                self2._input.removeEventListener("focus", self2.open);
                self2._input.removeEventListener("click", self2.open);
              }
            }
          ]
        };
        function set(option, value) {
          if (option !== null && typeof option === "object") {
            Object.assign(self2.config, option);
            for (var key in option) {
              if (CALLBACKS[key] !== void 0)
                CALLBACKS[key].forEach(function(x2) {
                  return x2();
                });
            }
          } else {
            self2.config[option] = value;
            if (CALLBACKS[option] !== void 0)
              CALLBACKS[option].forEach(function(x2) {
                return x2();
              });
            else if (HOOKS.indexOf(option) > -1)
              self2.config[option] = arrayify(value);
          }
          self2.redraw();
          updateValue(true);
        }
        function setSelectedDate(inputDate, format2) {
          var dates = [];
          if (inputDate instanceof Array)
            dates = inputDate.map(function(d) {
              return self2.parseDate(d, format2);
            });
          else if (inputDate instanceof Date || typeof inputDate === "number")
            dates = [self2.parseDate(inputDate, format2)];
          else if (typeof inputDate === "string") {
            switch (self2.config.mode) {
              case "single":
              case "time":
                dates = [self2.parseDate(inputDate, format2)];
                break;
              case "multiple":
                dates = inputDate.split(self2.config.conjunction).map(function(date) {
                  return self2.parseDate(date, format2);
                });
                break;
              case "range":
                dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
                  return self2.parseDate(date, format2);
                });
                break;
            }
          } else
            self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
          self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d) {
            return d instanceof Date && isEnabled(d, false);
          });
          if (self2.config.mode === "range")
            self2.selectedDates.sort(function(a, b) {
              return a.getTime() - b.getTime();
            });
        }
        function setDate(date, triggerChange2, format2) {
          if (triggerChange2 === void 0) {
            triggerChange2 = false;
          }
          if (format2 === void 0) {
            format2 = self2.config.dateFormat;
          }
          if (date !== 0 && !date || date instanceof Array && date.length === 0)
            return self2.clear(triggerChange2);
          setSelectedDate(date, format2);
          self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
          self2.redraw();
          jumpToDate(void 0, triggerChange2);
          setHoursFromDate();
          if (self2.selectedDates.length === 0) {
            self2.clear(false);
          }
          updateValue(triggerChange2);
          if (triggerChange2)
            triggerEvent("onChange");
        }
        function parseDateRules(arr) {
          return arr.slice().map(function(rule) {
            if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
              return self2.parseDate(rule, void 0, true);
            } else if (rule && typeof rule === "object" && rule.from && rule.to)
              return {
                from: self2.parseDate(rule.from, void 0),
                to: self2.parseDate(rule.to, void 0)
              };
            return rule;
          }).filter(function(x2) {
            return x2;
          });
        }
        function setupDates() {
          self2.selectedDates = [];
          self2.now = self2.parseDate(self2.config.now) || new Date();
          var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
          if (preloadedDate)
            setSelectedDate(preloadedDate, self2.config.dateFormat);
          self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
          self2.currentYear = self2._initialDate.getFullYear();
          self2.currentMonth = self2._initialDate.getMonth();
          if (self2.selectedDates.length > 0)
            self2.latestSelectedDateObj = self2.selectedDates[0];
          if (self2.config.minTime !== void 0)
            self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
          if (self2.config.maxTime !== void 0)
            self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
          self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
          self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
        }
        function setupInputs() {
          self2.input = getInputElem();
          if (!self2.input) {
            self2.config.errorHandler(new Error("Invalid input element specified"));
            return;
          }
          self2.input._type = self2.input.type;
          self2.input.type = "text";
          self2.input.classList.add("flatpickr-input");
          self2._input = self2.input;
          if (self2.config.altInput) {
            self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
            self2._input = self2.altInput;
            self2.altInput.placeholder = self2.input.placeholder;
            self2.altInput.disabled = self2.input.disabled;
            self2.altInput.required = self2.input.required;
            self2.altInput.tabIndex = self2.input.tabIndex;
            self2.altInput.type = "text";
            self2.input.setAttribute("type", "hidden");
            if (!self2.config.static && self2.input.parentNode)
              self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
          }
          if (!self2.config.allowInput)
            self2._input.setAttribute("readonly", "readonly");
          self2._positionElement = self2.config.positionElement || self2._input;
        }
        function setupMobile() {
          var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
          self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
          self2.mobileInput.tabIndex = 1;
          self2.mobileInput.type = inputType;
          self2.mobileInput.disabled = self2.input.disabled;
          self2.mobileInput.required = self2.input.required;
          self2.mobileInput.placeholder = self2.input.placeholder;
          self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
          if (self2.selectedDates.length > 0) {
            self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
          }
          if (self2.config.minDate)
            self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
          if (self2.config.maxDate)
            self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
          if (self2.input.getAttribute("step"))
            self2.mobileInput.step = String(self2.input.getAttribute("step"));
          self2.input.type = "hidden";
          if (self2.altInput !== void 0)
            self2.altInput.type = "hidden";
          try {
            if (self2.input.parentNode)
              self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
          } catch (_a) {
          }
          bind(self2.mobileInput, "change", function(e) {
            self2.setDate(getEventTarget(e).value, false, self2.mobileFormatStr);
            triggerEvent("onChange");
            triggerEvent("onClose");
          });
        }
        function toggle(e) {
          if (self2.isOpen === true)
            return self2.close();
          self2.open(e);
        }
        function triggerEvent(event, data) {
          if (self2.config === void 0)
            return;
          var hooks = self2.config[event];
          if (hooks !== void 0 && hooks.length > 0) {
            for (var i = 0; hooks[i] && i < hooks.length; i++)
              hooks[i](self2.selectedDates, self2.input.value, self2, data);
          }
          if (event === "onChange") {
            self2.input.dispatchEvent(createEvent("change"));
            self2.input.dispatchEvent(createEvent("input"));
          }
        }
        function createEvent(name) {
          var e = document.createEvent("Event");
          e.initEvent(name, true, true);
          return e;
        }
        function isDateSelected(date) {
          for (var i = 0; i < self2.selectedDates.length; i++) {
            if (compareDates(self2.selectedDates[i], date) === 0)
              return "" + i;
          }
          return false;
        }
        function isDateInRange(date) {
          if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
            return false;
          return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
        }
        function updateNavigationCurrentMonth() {
          if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
            return;
          self2.yearElements.forEach(function(yearElement, i) {
            var d = new Date(self2.currentYear, self2.currentMonth, 1);
            d.setMonth(self2.currentMonth + i);
            if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
              self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
            } else {
              self2.monthsDropdownContainer.value = d.getMonth().toString();
            }
            yearElement.value = d.getFullYear().toString();
          });
          self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
          self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
        }
        function getDateStr(format2) {
          return self2.selectedDates.map(function(dObj) {
            return self2.formatDate(dObj, format2);
          }).filter(function(d, i, arr) {
            return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i;
          }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
        }
        function updateValue(triggerChange2) {
          if (triggerChange2 === void 0) {
            triggerChange2 = true;
          }
          if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
            self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
          }
          self2.input.value = getDateStr(self2.config.dateFormat);
          if (self2.altInput !== void 0) {
            self2.altInput.value = getDateStr(self2.config.altFormat);
          }
          if (triggerChange2 !== false)
            triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
          var eventTarget = getEventTarget(e);
          var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
          var isNextMonth = self2.nextMonthNav.contains(eventTarget);
          if (isPrevMonth || isNextMonth) {
            changeMonth(isPrevMonth ? -1 : 1);
          } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
            eventTarget.select();
          } else if (eventTarget.classList.contains("arrowUp")) {
            self2.changeYear(self2.currentYear + 1);
          } else if (eventTarget.classList.contains("arrowDown")) {
            self2.changeYear(self2.currentYear - 1);
          }
        }
        function timeWrapper(e) {
          e.preventDefault();
          var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
          if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
            self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
          }
          var min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
          var newValue = curValue + step * delta;
          if (typeof input.value !== "undefined" && input.value.length === 2) {
            var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
            if (newValue < min2) {
              newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
              if (isMinuteElem)
                incrementNumInput(void 0, -1, self2.hourElement);
            } else if (newValue > max2) {
              newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
              if (isMinuteElem)
                incrementNumInput(void 0, 1, self2.hourElement);
            }
            if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
              self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
            }
            input.value = pad(newValue);
          }
        }
        init();
        return self2;
      }
      function _flatpickr(nodeList, config) {
        var nodes = Array.prototype.slice.call(nodeList).filter(function(x2) {
          return x2 instanceof HTMLElement;
        });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          try {
            if (node.getAttribute("data-fp-omit") !== null)
              continue;
            if (node._flatpickr !== void 0) {
              node._flatpickr.destroy();
              node._flatpickr = void 0;
            }
            node._flatpickr = FlatpickrInstance(node, config || {});
            instances.push(node._flatpickr);
          } catch (e) {
            console.error(e);
          }
        }
        return instances.length === 1 ? instances[0] : instances;
      }
      if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
          return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function(config) {
          return _flatpickr([this], config);
        };
      }
      var flatpickr = function(selector, config) {
        if (typeof selector === "string") {
          return _flatpickr(window.document.querySelectorAll(selector), config);
        } else if (selector instanceof Node) {
          return _flatpickr([selector], config);
        } else {
          return _flatpickr(selector, config);
        }
      };
      flatpickr.defaultConfig = {};
      flatpickr.l10ns = {
        en: __assign({}, english),
        default: __assign({}, english)
      };
      flatpickr.localize = function(l10n) {
        flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
      };
      flatpickr.setDefaults = function(config) {
        flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
      };
      flatpickr.parseDate = createDateParser({});
      flatpickr.formatDate = createDateFormatter({});
      flatpickr.compareDates = compareDates;
      if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
        jQuery.fn.flatpickr = function(config) {
          return _flatpickr(this, config);
        };
      }
      Date.prototype.fp_incr = function(days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
      };
      if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
      }
      return flatpickr;
    });
  }
});

// node_modules/react-flatpickr/build/index.js
var require_build = __commonJS({
  "node_modules/react-flatpickr/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireWildcard(require("react"));
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _flatpickr = _interopRequireDefault(require_flatpickr());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var hooks = ["onChange", "onOpen", "onClose", "onMonthChange", "onYearChange", "onReady", "onValueUpdate", "onDayCreate"];
    var hookPropType = _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].arrayOf(_propTypes["default"].func)]);
    var callbacks = ["onCreate", "onDestroy"];
    var callbackPropTypes = _propTypes["default"].func;
    var DateTimePicker = /* @__PURE__ */ function(_Component) {
      _inherits(DateTimePicker2, _Component);
      var _super = _createSuper(DateTimePicker2);
      function DateTimePicker2() {
        var _this;
        _classCallCheck(this, DateTimePicker2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "createFlatpickrInstance", function() {
          var options = _objectSpread({
            onClose: function onClose() {
              _this.node.blur && _this.node.blur();
            }
          }, _this.props.options);
          hooks.forEach(function(hook) {
            if (_this.props[hook]) {
              options[hook] = _this.props[hook];
            }
          });
          _this.flatpickr = (0, _flatpickr["default"])(_this.node, options);
          if (_this.props.hasOwnProperty("value")) {
            _this.flatpickr.setDate(_this.props.value, false);
          }
          var onCreate = _this.props.onCreate;
          if (onCreate)
            onCreate(_this.flatpickr);
        });
        _defineProperty(_assertThisInitialized(_this), "destroyFlatpickrInstance", function() {
          var onDestroy = _this.props.onDestroy;
          if (onDestroy)
            onDestroy(_this.flatpickr);
          _this.flatpickr.destroy();
          _this.flatpickr = null;
        });
        _defineProperty(_assertThisInitialized(_this), "handleNodeChange", function(node) {
          _this.node = node;
          if (_this.flatpickr) {
            _this.destroyFlatpickrInstance();
            _this.createFlatpickrInstance();
          }
        });
        return _this;
      }
      _createClass(DateTimePicker2, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var _this2 = this;
          var options = this.props.options;
          var prevOptions = prevProps.options;
          hooks.forEach(function(hook) {
            if (_this2.props.hasOwnProperty(hook)) {
              options[hook] = _this2.props[hook];
            }
            if (prevProps.hasOwnProperty(hook)) {
              prevOptions[hook] = prevProps[hook];
            }
          });
          var optionsKeys = Object.getOwnPropertyNames(options);
          for (var index = optionsKeys.length - 1; index >= 0; index--) {
            var key = optionsKeys[index];
            var value = options[key];
            if (value !== prevOptions[key]) {
              if (hooks.indexOf(key) !== -1 && !Array.isArray(value)) {
                value = [value];
              }
              this.flatpickr.set(key, value);
            }
          }
          if (this.props.hasOwnProperty("value") && this.props.value !== prevProps.value) {
            this.flatpickr.setDate(this.props.value, false);
          }
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          this.createFlatpickrInstance();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.destroyFlatpickrInstance();
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props = this.props, options = _this$props.options, defaultValue = _this$props.defaultValue, value = _this$props.value, children = _this$props.children, render2 = _this$props.render, props = _objectWithoutProperties(_this$props, ["options", "defaultValue", "value", "children", "render"]);
          hooks.forEach(function(hook) {
            delete props[hook];
          });
          callbacks.forEach(function(callback) {
            delete props[callback];
          });
          if (render2)
            return render2(_objectSpread(_objectSpread({}, props), {}, {
              defaultValue,
              value
            }), this.handleNodeChange);
          return options.wrap ? /* @__PURE__ */ _react["default"].createElement("div", _extends({}, props, {
            ref: this.handleNodeChange
          }), children) : /* @__PURE__ */ _react["default"].createElement("input", _extends({}, props, {
            defaultValue,
            ref: this.handleNodeChange
          }));
        }
      }]);
      return DateTimePicker2;
    }(_react.Component);
    _defineProperty(DateTimePicker, "propTypes", {
      defaultValue: _propTypes["default"].string,
      options: _propTypes["default"].object,
      onChange: hookPropType,
      onOpen: hookPropType,
      onClose: hookPropType,
      onMonthChange: hookPropType,
      onYearChange: hookPropType,
      onReady: hookPropType,
      onValueUpdate: hookPropType,
      onDayCreate: hookPropType,
      onCreate: callbackPropTypes,
      onDestroy: callbackPropTypes,
      value: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object, _propTypes["default"].number]),
      children: _propTypes["default"].node,
      className: _propTypes["default"].string,
      render: _propTypes["default"].func
    });
    _defineProperty(DateTimePicker, "defaultProps", {
      options: {}
    });
    var _default = DateTimePicker;
    exports["default"] = _default;
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module2) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        var it2;
        if (hasMap && a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          it2 = a.entries();
          while (!(i = it2.next()).done)
            if (!b.has(i.value[0]))
              return false;
          it2 = a.entries();
          while (!(i = it2.next()).done)
            if (!equal(i.value[1], b.get(i.value[0])))
              return false;
          return true;
        }
        if (hasSet && a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          it2 = a.entries();
          while (!(i = it2.next()).done)
            if (!b.has(i.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        if (hasElementType && a instanceof Element)
          return false;
        for (i = length; i-- !== 0; ) {
          if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
            continue;
          }
          if (!equal(a[keys[i]], b[keys[i]]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    module2.exports = function isEqual2(a, b) {
      try {
        return equal(a, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});

// node_modules/debounce-promise/dist/index.js
var require_dist = __commonJS({
  "node_modules/debounce-promise/dist/index.js"(exports, module2) {
    "use strict";
    module2.exports = function debounce3(fn2) {
      var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var lastCallAt = void 0;
      var deferred = void 0;
      var timer = void 0;
      var pendingArgs = [];
      return function debounced() {
        var currentWait = getWait(wait);
        var currentTime = new Date().getTime();
        var isCold = !lastCallAt || currentTime - lastCallAt > currentWait;
        lastCallAt = currentTime;
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (isCold && options.leading) {
          return options.accumulate ? Promise.resolve(fn2.call(this, [args])).then(function(result) {
            return result[0];
          }) : Promise.resolve(fn2.call.apply(fn2, [this].concat(args)));
        }
        if (deferred) {
          clearTimeout(timer);
        } else {
          deferred = defer();
        }
        pendingArgs.push(args);
        timer = setTimeout(flush.bind(this), currentWait);
        if (options.accumulate) {
          var argsIndex = pendingArgs.length - 1;
          return deferred.promise.then(function(results) {
            return results[argsIndex];
          });
        }
        return deferred.promise;
      };
      function flush() {
        var thisDeferred = deferred;
        clearTimeout(timer);
        Promise.resolve(options.accumulate ? fn2.call(this, pendingArgs) : fn2.apply(this, pendingArgs[pendingArgs.length - 1])).then(thisDeferred.resolve, thisDeferred.reject);
        pendingArgs = [];
        deferred = null;
      }
    };
    function getWait(wait) {
      return typeof wait === "function" ? wait() : wait;
    }
    function defer() {
      var deferred = {};
      deferred.promise = new Promise(function(resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
      });
      return deferred;
    }
  }
});

// src/lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  DateInput: () => DateInput,
  GuestSelect: () => GuestSelect,
  LocationSelect: () => LocationSelect,
  mergeRefs: () => mergeRefs,
  useReactBookingForm: () => useReactBookingForm
});
module.exports = __toCommonJS(lib_exports);

// src/lib/use-react-booking-form.ts
var import_react = require("react");
var getGuestTotalCount = (guestOptions) => guestOptions.reduce((acc, guestOption) => acc + guestOption.value, 0);
var getFieldKeysToSwap = (formState) => {
  const firstLocation = Object.keys(formState).find((key) => formState[key].type === "location");
  const secondLocation = Object.keys(formState).find((key) => key !== firstLocation && formState[key].type === "location");
  if (!firstLocation || !secondLocation)
    return null;
  return [firstLocation, secondLocation];
};
var useReactBookingForm = ({
  formSchema
}) => {
  const [state, setState] = (0, import_react.useState)(() => {
    const result = {};
    Object.keys(formSchema).forEach((key) => {
      const field = formSchema[key];
      result[key] = {
        type: field.type,
        value: field.defaultValue,
        totalCount: field.type === "peopleCount" ? getGuestTotalCount(field.defaultValue) : void 0
      };
    });
    return result;
  });
  const refs = (0, import_react.useMemo)(() => {
    return Object.keys(formSchema).reduce((acc, key) => {
      acc[key] = (0, import_react.createRef)();
      return acc;
    }, {});
  }, []);
  const focusOn = (0, import_react.useCallback)((name) => {
    var _a, _b, _c, _d, _e2, _f;
    if (!name)
      return;
    const itemType = state[name].type;
    if (itemType === "date") {
      let child = (_a = refs[name].current) == null ? void 0 : _a.querySelector("[data-input]");
      if ((child == null ? void 0 : child.getAttribute("type")) === "hidden") {
        child = (_b = refs[name].current) == null ? void 0 : _b.querySelector(".form-control.input");
      }
      child == null ? void 0 : child.focus();
      return;
    }
    if (itemType === "location") {
      return (_d = (_c = refs[name].current) == null ? void 0 : _c.focus) == null ? void 0 : _d.call(_c);
    }
    (_f = (_e2 = refs[name].current) == null ? void 0 : _e2.click) == null ? void 0 : _f.call(_e2);
  }, [refs]);
  const setFieldValue = (0, import_react.useCallback)((key, value) => {
    setState((state2) => ({ ...state2, [key]: { ...state2[key], value } }));
  }, []);
  const setFieldState = (0, import_react.useCallback)((key, fieldState) => {
    setState((state2) => ({ ...state2, [key]: { ...state2[key], ...fieldState } }));
  }, []);
  const setGuestOptionValue = (0, import_react.useCallback)((key, option, value) => {
    const newStateItemValue = [...state[key].value];
    const optionIndex = newStateItemValue.findIndex((stateItemValue) => option.name === stateItemValue.name);
    newStateItemValue[optionIndex].value = value;
    setFieldState(key, {
      value: newStateItemValue,
      totalCount: getGuestTotalCount(newStateItemValue)
    });
  }, [state]);
  const onMinusClick = (0, import_react.useCallback)((option, name) => () => {
    setGuestOptionValue(name, option, option.value - 1);
  }, [setGuestOptionValue]);
  const onPlusClick = (0, import_react.useCallback)((option, name) => () => {
    setGuestOptionValue(name, option, option.value + 1);
  }, [setGuestOptionValue]);
  const getIsOptionDisabled = (0, import_react.useCallback)((option, optionButtonType) => optionButtonType === "plus" ? option.value >= (option.max || 100) : option.value === 0, []);
  const swapLocations = (0, import_react.useCallback)((fieldKeys) => {
    const fieldKeysToSwap = (fieldKeys == null ? void 0 : fieldKeys.length) === 2 ? fieldKeys : getFieldKeysToSwap(state);
    if (!fieldKeysToSwap)
      return;
    setFieldState(fieldKeysToSwap[0], state[fieldKeysToSwap[1]]);
    setFieldState(fieldKeysToSwap[1], state[fieldKeysToSwap[0]]);
  }, [state]);
  const serializeToURLParams = (0, import_react.useCallback)(({ convertDate }) => {
    const params = {};
    Object.keys(state).forEach((key) => {
      var _a, _b;
      const field = state[key];
      let value = "";
      if (field.type === "date") {
        const newValue = (_a = field.value) == null ? void 0 : _a[0];
        value = convertDate ? convertDate(newValue) : newValue;
      }
      if (field.type === "peopleCount") {
        field.value.forEach((option) => {
          params[`${key}-${option.name}`] = option.value;
        });
        return;
      }
      if (field.type === "location") {
        value = (_b = field.value) == null ? void 0 : _b.value;
      }
      params[key] = value;
    });
    return new URLSearchParams(params).toString();
  }, [state]);
  const bookingForm = (0, import_react.useMemo)(() => ({
    formSchema,
    state,
    setState,
    setFieldValue,
    setFieldState,
    refs,
    focusOn,
    setGuestOptionValue,
    onMinusClick,
    onPlusClick,
    getIsOptionDisabled,
    swapLocations,
    serializeToURLParams
  }), [
    formSchema,
    state,
    setState,
    refs,
    setFieldValue,
    focusOn,
    setFieldState,
    onMinusClick,
    onPlusClick,
    getIsOptionDisabled,
    swapLocations,
    serializeToURLParams
  ]);
  return bookingForm;
};

// src/lib/date-input.tsx
var import_react2 = __toESM(require("react"));
var import_react_flatpickr = __toESM(require_build());
var DateInput = ({
  placeholder,
  inputComponent: InputComponent,
  className,
  name,
  form
}) => {
  const item = form.formSchema[name];
  const onChange = (value) => {
    form.setFieldValue(name, value);
    setTimeout(() => {
      form.focusOn(item.focusOnNext);
    }, 0);
  };
  const options = (0, import_react2.useMemo)(() => {
    var _a, _b;
    const minDateFrom = (_a = item == null ? void 0 : item.options) == null ? void 0 : _a.minDateFrom;
    if (!minDateFrom)
      return { ...item.options };
    const minDate = minDateFrom ? (_b = form.state[minDateFrom].value) == null ? void 0 : _b[0] : null;
    return { ...item.options, minDate: minDate || void 0 };
  }, [form.state]);
  return /* @__PURE__ */ import_react2.default.createElement(import_react_flatpickr.default, {
    className,
    onChange,
    options
  }, /* @__PURE__ */ import_react2.default.createElement(InputComponent, {
    placeholder,
    form,
    name,
    containerRef: form.refs[name]
  }));
};

// src/lib/guest-select.tsx
var import_react36 = __toESM(require("react"));

// node_modules/@headlessui/react/dist/headlessui.esm.js
var import_react3 = __toESM(require("react"), 1);
var import_react4 = require("react");
var import_react5 = require("react");
var import_react6 = require("react");
var import_react7 = require("react");
var import_react8 = require("react");
var import_react9 = require("react");
var import_react10 = require("react");
var import_react11 = require("react");
var import_react12 = require("react");
var import_react13 = __toESM(require("react"), 1);
var import_react14 = require("react");
var import_react15 = require("react");
var import_react16 = __toESM(require("react"), 1);
var import_react17 = require("react");
var import_react18 = require("react");
var import_react19 = __toESM(require("react"), 1);
var import_react_dom = require("react-dom");
var import_react20 = __toESM(require("react"), 1);
var import_react21 = __toESM(require("react"), 1);
var import_react22 = __toESM(require("react"), 1);
var import_react23 = __toESM(require("react"), 1);
var import_react24 = require("react");
var import_react25 = __toESM(require("react"), 1);
var import_react26 = __toESM(require("react"), 1);
var import_react27 = __toESM(require("react"), 1);
var import_react28 = __toESM(require("react"), 1);
var import_react29 = require("react");
var import_react30 = __toESM(require("react"), 1);
var import_react31 = __toESM(require("react"), 1);
var import_react32 = __toESM(require("react"), 1);
var import_react33 = __toESM(require("react"), 1);
var import_react34 = require("react");
function k() {
  let e = [], t = [], r = { enqueue(o) {
    t.push(o);
  }, requestAnimationFrame(...o) {
    let n = requestAnimationFrame(...o);
    r.add(() => cancelAnimationFrame(n));
  }, nextFrame(...o) {
    r.requestAnimationFrame(() => {
      r.requestAnimationFrame(...o);
    });
  }, setTimeout(...o) {
    let n = setTimeout(...o);
    r.add(() => clearTimeout(n));
  }, add(o) {
    e.push(o);
  }, dispose() {
    for (let o of e.splice(0))
      o();
  }, async workQueue() {
    for (let o of t.splice(0))
      await o();
  } };
  return r;
}
function Q() {
  let [e] = (0, import_react4.useState)(k);
  return (0, import_react4.useEffect)(() => () => e.dispose(), [e]), e;
}
var x = typeof window != "undefined" ? import_react6.useLayoutEffect : import_react6.useEffect;
var yt = { serverHandoffComplete: false };
function q() {
  let [e, t] = (0, import_react7.useState)(yt.serverHandoffComplete);
  return (0, import_react7.useEffect)(() => {
    e !== true && t(true);
  }, [e]), (0, import_react7.useEffect)(() => {
    yt.serverHandoffComplete === false && (yt.serverHandoffComplete = true);
  }, []), e;
}
var or = 0;
function to() {
  return ++or;
}
function A() {
  let e = q(), [t, r] = (0, import_react5.useState)(e ? to : null);
  return x(() => {
    t === null && r(to());
  }, [t]), t != null ? "" + t : void 0;
}
function ke(e) {
  let t = (0, import_react9.useRef)(e);
  return (0, import_react9.useEffect)(() => {
    t.current = e;
  }, [e]), t;
}
function ee(e, t) {
  let [r, o] = (0, import_react8.useState)(e), n = ke(e);
  return x(() => o(n.current), [n, o, ...t]), r;
}
function I(...e) {
  let t = (0, import_react10.useRef)(e);
  return (0, import_react10.useEffect)(() => {
    t.current = e;
  }, [e]), (0, import_react10.useCallback)((r) => {
    for (let o of t.current)
      o != null && (typeof o == "function" ? o(r) : o.current = r);
  }, [t]);
}
function S(e, t, ...r) {
  if (e in t) {
    let n = t[e];
    return typeof n == "function" ? n(...r) : n;
  }
  let o = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map((n) => `"${n}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(o, S), o;
}
function E({ props: e, slot: t, defaultTag: r, features: o, visible: n = true, name: i }) {
  if (n)
    return _e(e, t, r, i);
  let a = o != null ? o : 0;
  if (a & 2) {
    let { static: l = false, ...s } = e;
    if (l)
      return _e(s, t, r, i);
  }
  if (a & 1) {
    let { unmount: l = true, ...s } = e;
    return S(l ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return _e({ ...s, hidden: true, style: { display: "none" } }, t, r, i);
    } });
  }
  return _e(e, t, r, i);
}
function _e(e, t = {}, r, o) {
  let { as: n = r, children: i, refName: a = "ref", ...l } = gt(e, ["unmount", "static"]), s = e.ref !== void 0 ? { [a]: e.ref } : {}, u = typeof i == "function" ? i(t) : i;
  if (l.className && typeof l.className == "function" && (l.className = l.className(t)), n === import_react11.Fragment && Object.keys(l).length > 0) {
    if (!(0, import_react11.isValidElement)(u) || Array.isArray(u) && u.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${o} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(l).map((c) => `  - ${c}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((c) => `  - ${c}`).join(`
`)].join(`
`));
    return (0, import_react11.cloneElement)(u, Object.assign({}, fr(mr(gt(l, ["ref"])), u.props, ["onClick"]), s));
  }
  return (0, import_react11.createElement)(n, Object.assign({}, gt(l, ["ref"]), n !== import_react11.Fragment && s), u);
}
function fr(e, t, r) {
  let o = Object.assign({}, e);
  for (let n of r)
    e[n] !== void 0 && t[n] !== void 0 && Object.assign(o, { [n](i) {
      i.defaultPrevented || e[n](i), i.defaultPrevented || t[n](i);
    } });
  return o;
}
function D(e) {
  var t;
  return Object.assign((0, import_react11.forwardRef)(e), { displayName: (t = e.displayName) != null ? t : e.name });
}
function mr(e) {
  let t = Object.assign({}, e);
  for (let r in t)
    t[r] === void 0 && delete t[r];
  return t;
}
function gt(e, t = []) {
  let r = Object.assign({}, e);
  for (let o of t)
    o in r && delete r[o];
  return r;
}
function br(e) {
  throw new Error("Unexpected object: " + e);
}
function ae(e, t) {
  let r = t.resolveItems();
  if (r.length <= 0)
    return null;
  let o = t.resolveActiveIndex(), n = o != null ? o : -1, i = (() => {
    switch (e.focus) {
      case 0:
        return r.findIndex((a) => !t.resolveDisabled(a));
      case 1: {
        let a = r.slice().reverse().findIndex((l, s, u) => n !== -1 && u.length - s - 1 >= n ? false : !t.resolveDisabled(l));
        return a === -1 ? a : r.length - 1 - a;
      }
      case 2:
        return r.findIndex((a, l) => l <= n ? false : !t.resolveDisabled(a));
      case 3: {
        let a = r.slice().reverse().findIndex((l) => !t.resolveDisabled(l));
        return a === -1 ? a : r.length - 1 - a;
      }
      case 4:
        return r.findIndex((a) => t.resolveId(a) === e.id);
      case 5:
        return null;
      default:
        br(e);
    }
  })();
  return i === -1 ? o : i;
}
function G(e) {
  let t = e.parentElement, r = null;
  for (; t && !(t instanceof HTMLFieldSetElement); )
    t instanceof HTMLLegendElement && (r = t), t = t.parentElement;
  let o = (t == null ? void 0 : t.getAttribute("disabled")) === "";
  return o && Tr(r) ? false : o;
}
function Tr(e) {
  if (!e)
    return false;
  let t = e.previousElementSibling;
  for (; t !== null; ) {
    if (t instanceof HTMLLegendElement)
      return false;
    t = t.previousElementSibling;
  }
  return true;
}
function w(e, t, r) {
  let o = (0, import_react12.useRef)(t);
  o.current = t, (0, import_react12.useEffect)(() => {
    function n(i) {
      o.current.call(window, i);
    }
    return window.addEventListener(e, n, r), () => window.removeEventListener(e, n, r);
  }, [e, r]);
}
var Pt = (0, import_react13.createContext)(null);
Pt.displayName = "OpenClosedContext";
function _() {
  return (0, import_react13.useContext)(Pt);
}
function W({ value: e, children: t }) {
  return import_react13.default.createElement(Pt.Provider, { value: e }, t);
}
function ro(e) {
  var r;
  if (e.type)
    return e.type;
  let t = (r = e.as) != null ? r : "button";
  if (typeof t == "string" && t.toLowerCase() === "button")
    return "button";
}
function U(e, t) {
  let [r, o] = (0, import_react14.useState)(() => ro(e));
  return x(() => {
    o(ro(e));
  }, [e.type, e.as]), x(() => {
    r || !t.current || t.current instanceof HTMLButtonElement && !t.current.hasAttribute("type") && o("button");
  }, [r, t]), r;
}
function se({ container: e, accept: t, walk: r, enabled: o = true }) {
  let n = (0, import_react15.useRef)(t), i = (0, import_react15.useRef)(r);
  (0, import_react15.useEffect)(() => {
    n.current = t, i.current = r;
  }, [t, r]), x(() => {
    if (!e || !o)
      return;
    let a = n.current, l = i.current, s = Object.assign((c) => a(c), { acceptNode: a }), u = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, s, false);
    for (; u.nextNode(); )
      l(u.currentNode);
  }, [e, o, n, i]);
}
var Ar = { [1](e) {
  return e.disabled || e.comboboxState === 1 ? e : { ...e, activeOptionIndex: null, comboboxState: 1 };
}, [0](e) {
  return e.disabled || e.comboboxState === 0 ? e : { ...e, comboboxState: 0 };
}, [2](e, t) {
  return e.disabled === t.disabled ? e : { ...e, disabled: t.disabled };
}, [3](e, t) {
  if (e.disabled || e.optionsRef.current && !e.optionsPropsRef.current.static && e.comboboxState === 1)
    return e;
  let r = ae(t, { resolveItems: () => e.options, resolveActiveIndex: () => e.activeOptionIndex, resolveId: (o) => o.id, resolveDisabled: (o) => o.dataRef.current.disabled });
  return e.activeOptionIndex === r ? e : { ...e, activeOptionIndex: r };
}, [4]: (e, t) => {
  var i;
  let r = e.activeOptionIndex !== null ? e.options[e.activeOptionIndex] : null, o = Array.from((i = e.optionsRef.current) == null ? void 0 : i.querySelectorAll('[id^="headlessui-combobox-option-"]')).reduce((a, l, s) => Object.assign(a, { [l.id]: s }), {}), n = [...e.options, { id: t.id, dataRef: t.dataRef }].sort((a, l) => o[a.id] - o[l.id]);
  return { ...e, options: n, activeOptionIndex: (() => r === null ? null : n.indexOf(r))() };
}, [5]: (e, t) => {
  let r = e.options.slice(), o = e.activeOptionIndex !== null ? r[e.activeOptionIndex] : null, n = r.findIndex((i) => i.id === t.id);
  return n !== -1 && r.splice(n, 1), { ...e, options: r, activeOptionIndex: (() => n === e.activeOptionIndex || o === null ? null : r.indexOf(o))() };
} };
var vt = (0, import_react3.createContext)(null);
vt.displayName = "ComboboxContext";
function pe(e) {
  let t = (0, import_react3.useContext)(vt);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, pe), r;
  }
  return t;
}
var Rt = (0, import_react3.createContext)(null);
Rt.displayName = "ComboboxActions";
function Ue() {
  let e = (0, import_react3.useContext)(Rt);
  if (e === null) {
    let t = new Error("ComboboxActions is missing a parent <Combobox /> component.");
    throw Error.captureStackTrace && Error.captureStackTrace(t, Ue), t;
  }
  return e;
}
function hr(e, t) {
  return S(t.type, Ar, e, t);
}
var Or = import_react3.Fragment;
var Ir = D(function(t, r) {
  let { value: o, onChange: n, disabled: i = false, ...a } = t, l = (0, import_react3.useRef)({ value: o, onChange: n }), s = (0, import_react3.useRef)({ static: false, hold: false }), u = (0, import_react3.useRef)({ displayValue: void 0 }), c = (0, import_react3.useReducer)(hr, { comboboxState: 1, comboboxPropsRef: l, optionsPropsRef: s, inputPropsRef: u, labelRef: (0, import_react3.createRef)(), inputRef: (0, import_react3.createRef)(), buttonRef: (0, import_react3.createRef)(), optionsRef: (0, import_react3.createRef)(), disabled: i, options: [], activeOptionIndex: null }), [{ comboboxState: m, options: b, activeOptionIndex: T, optionsRef: y, inputRef: p, buttonRef: f }, d] = c;
  x(() => {
    l.current.value = o;
  }, [o, l]), x(() => {
    l.current.onChange = n;
  }, [n, l]), x(() => d({ type: 2, disabled: i }), [i]), w("mousedown", (O) => {
    var N, K, V;
    let L = O.target;
    m === 0 && (((N = f.current) == null ? void 0 : N.contains(L)) || ((K = p.current) == null ? void 0 : K.contains(L)) || ((V = y.current) == null ? void 0 : V.contains(L)) || d({ type: 1 }));
  });
  let P = T === null ? null : b[T].dataRef.current.value, C = (0, import_react3.useMemo)(() => ({ open: m === 0, disabled: i, activeIndex: T, activeOption: P }), [m, i, b, T]), R = (0, import_react3.useCallback)(() => {
    if (!p.current || o === void 0)
      return;
    let O = u.current.displayValue;
    typeof O == "function" ? p.current.value = O(o) : typeof o == "string" && (p.current.value = o);
  }, [o, p, u]), g = (0, import_react3.useCallback)((O) => {
    let L = b.find((K) => K.id === O);
    if (!L)
      return;
    let { dataRef: N } = L;
    l.current.onChange(N.current.value), R();
  }, [b, l, p]), v = (0, import_react3.useCallback)(() => {
    if (T !== null) {
      let { dataRef: O } = b[T];
      l.current.onChange(O.current.value), R();
    }
  }, [T, b, l, p]), h = (0, import_react3.useMemo)(() => ({ selectOption: g, selectActiveOption: v }), [g, v]);
  return x(() => {
    m === 1 && R();
  }, [R, m]), x(R, [R]), import_react3.default.createElement(Rt.Provider, { value: h }, import_react3.default.createElement(vt.Provider, { value: c }, import_react3.default.createElement(W, { value: S(m, { [0]: 0, [1]: 1 }) }, E({ props: r === null ? a : { ...a, ref: r }, slot: C, defaultTag: Or, name: "Combobox" }))));
});
var Lr = "input";
var Dr = D(function(t, r) {
  var R, g;
  let { value: o, onChange: n, displayValue: i, ...a } = t, [l, s] = pe("Combobox.Input"), u = Ue(), c = I(l.inputRef, r), m = l.inputPropsRef, b = `headlessui-combobox-input-${A()}`, T = Q(), y = ke(n);
  x(() => {
    m.current.displayValue = i;
  }, [i, m]);
  let p = (0, import_react3.useCallback)((v) => {
    switch (v.key) {
      case "Enter":
        v.preventDefault(), v.stopPropagation(), u.selectActiveOption(), s({ type: 1 });
        break;
      case "ArrowDown":
        return v.preventDefault(), v.stopPropagation(), S(l.comboboxState, { [0]: () => s({ type: 3, focus: 2 }), [1]: () => {
          s({ type: 0 }), T.nextFrame(() => {
            l.comboboxPropsRef.current.value || s({ type: 3, focus: 0 });
          });
        } });
      case "ArrowUp":
        return v.preventDefault(), v.stopPropagation(), S(l.comboboxState, { [0]: () => s({ type: 3, focus: 1 }), [1]: () => {
          s({ type: 0 }), T.nextFrame(() => {
            l.comboboxPropsRef.current.value || s({ type: 3, focus: 3 });
          });
        } });
      case "Home":
      case "PageUp":
        return v.preventDefault(), v.stopPropagation(), s({ type: 3, focus: 0 });
      case "End":
      case "PageDown":
        return v.preventDefault(), v.stopPropagation(), s({ type: 3, focus: 3 });
      case "Escape":
        return v.preventDefault(), l.optionsRef.current && !l.optionsPropsRef.current.static && v.stopPropagation(), s({ type: 1 });
      case "Tab":
        u.selectActiveOption(), s({ type: 1 });
        break;
    }
  }, [T, s, l, u]), f = (0, import_react3.useCallback)((v) => {
    var h;
    s({ type: 0 }), (h = y.current) == null || h.call(y, v);
  }, [s, y]), d = ee(() => {
    if (!!l.labelRef.current)
      return [l.labelRef.current.id].join(" ");
  }, [l.labelRef.current]), P = (0, import_react3.useMemo)(() => ({ open: l.comboboxState === 0, disabled: l.disabled }), [l]), C = { ref: c, id: b, role: "combobox", type: "text", "aria-controls": (R = l.optionsRef.current) == null ? void 0 : R.id, "aria-expanded": l.disabled ? void 0 : l.comboboxState === 0, "aria-activedescendant": l.activeOptionIndex === null || (g = l.options[l.activeOptionIndex]) == null ? void 0 : g.id, "aria-labelledby": d, disabled: l.disabled, onKeyDown: p, onChange: f };
  return E({ props: { ...a, ...C }, slot: P, defaultTag: Lr, name: "Combobox.Input" });
});
var Mr = "button";
var Fr = D(function(t, r) {
  var p;
  let [o, n] = pe("Combobox.Button"), i = Ue(), a = I(o.buttonRef, r), l = `headlessui-combobox-button-${A()}`, s = Q(), u = (0, import_react3.useCallback)((f) => {
    switch (f.key) {
      case "ArrowDown":
        return f.preventDefault(), f.stopPropagation(), o.comboboxState === 1 && (n({ type: 0 }), s.nextFrame(() => {
          o.comboboxPropsRef.current.value || n({ type: 3, focus: 0 });
        })), s.nextFrame(() => {
          var d;
          return (d = o.inputRef.current) == null ? void 0 : d.focus({ preventScroll: true });
        });
      case "ArrowUp":
        return f.preventDefault(), f.stopPropagation(), o.comboboxState === 1 && (n({ type: 0 }), s.nextFrame(() => {
          o.comboboxPropsRef.current.value || n({ type: 3, focus: 3 });
        })), s.nextFrame(() => {
          var d;
          return (d = o.inputRef.current) == null ? void 0 : d.focus({ preventScroll: true });
        });
      case "Escape":
        return f.preventDefault(), o.optionsRef.current && !o.optionsPropsRef.current.static && f.stopPropagation(), n({ type: 1 }), s.nextFrame(() => {
          var d;
          return (d = o.inputRef.current) == null ? void 0 : d.focus({ preventScroll: true });
        });
    }
  }, [s, n, o, i]), c = (0, import_react3.useCallback)((f) => {
    if (G(f.currentTarget))
      return f.preventDefault();
    o.comboboxState === 0 ? n({ type: 1 }) : (f.preventDefault(), n({ type: 0 })), s.nextFrame(() => {
      var d;
      return (d = o.inputRef.current) == null ? void 0 : d.focus({ preventScroll: true });
    });
  }, [n, s, o]), m = ee(() => {
    if (!!o.labelRef.current)
      return [o.labelRef.current.id, l].join(" ");
  }, [o.labelRef.current, l]), b = (0, import_react3.useMemo)(() => ({ open: o.comboboxState === 0, disabled: o.disabled }), [o]), T = t, y = { ref: a, id: l, type: U(t, o.buttonRef), tabIndex: -1, "aria-haspopup": true, "aria-controls": (p = o.optionsRef.current) == null ? void 0 : p.id, "aria-expanded": o.disabled ? void 0 : o.comboboxState === 0, "aria-labelledby": m, disabled: o.disabled, onClick: c, onKeyDown: u };
  return E({ props: { ...T, ...y }, slot: b, defaultTag: Mr, name: "Combobox.Button" });
});
var wr = "label";
function kr(e) {
  let [t] = pe("Combobox.Label"), r = `headlessui-combobox-label-${A()}`, o = (0, import_react3.useCallback)(() => {
    var a;
    return (a = t.inputRef.current) == null ? void 0 : a.focus({ preventScroll: true });
  }, [t.inputRef]), n = (0, import_react3.useMemo)(() => ({ open: t.comboboxState === 0, disabled: t.disabled }), [t]), i = { ref: t.labelRef, id: r, onClick: o };
  return E({ props: { ...e, ...i }, slot: n, defaultTag: wr, name: "Combobox.Label" });
}
var _r = "ul";
var Gr = 1 | 2;
var Hr = D(function(t, r) {
  var y;
  let { hold: o = false, ...n } = t, [i] = pe("Combobox.Options"), { optionsPropsRef: a } = i, l = I(i.optionsRef, r), s = `headlessui-combobox-options-${A()}`, u = _(), c = (() => u !== null ? u === 0 : i.comboboxState === 0)();
  x(() => {
    var p;
    a.current.static = (p = t.static) != null ? p : false;
  }, [a, t.static]), x(() => {
    a.current.hold = o;
  }, [o, a]), se({ container: i.optionsRef.current, enabled: i.comboboxState === 0, accept(p) {
    return p.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : p.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(p) {
    p.setAttribute("role", "none");
  } });
  let m = ee(() => {
    var p, f, d;
    return (d = (p = i.labelRef.current) == null ? void 0 : p.id) != null ? d : (f = i.buttonRef.current) == null ? void 0 : f.id;
  }, [i.labelRef.current, i.buttonRef.current]), b = (0, import_react3.useMemo)(() => ({ open: i.comboboxState === 0 }), [i]), T = { "aria-activedescendant": i.activeOptionIndex === null || (y = i.options[i.activeOptionIndex]) == null ? void 0 : y.id, "aria-labelledby": m, role: "listbox", id: s, ref: l };
  return E({ props: { ...n, ...T }, slot: b, defaultTag: _r, features: Gr, visible: c, name: "Combobox.Options" });
});
var Ur = "li";
function Br(e) {
  let { disabled: t = false, value: r, ...o } = e, [n, i] = pe("Combobox.Option"), a = Ue(), l = `headlessui-combobox-option-${A()}`, s = n.activeOptionIndex !== null ? n.options[n.activeOptionIndex].id === l : false, u = n.comboboxPropsRef.current.value === r, c = (0, import_react3.useRef)({ disabled: t, value: r });
  x(() => {
    c.current.disabled = t;
  }, [c, t]), x(() => {
    c.current.value = r;
  }, [c, r]), x(() => {
    var P, C;
    c.current.textValue = (C = (P = document.getElementById(l)) == null ? void 0 : P.textContent) == null ? void 0 : C.toLowerCase();
  }, [c, l]);
  let m = (0, import_react3.useCallback)(() => a.selectOption(l), [a, l]);
  x(() => (i({ type: 4, id: l, dataRef: c }), () => i({ type: 5, id: l })), [c, l]), x(() => {
    n.comboboxState === 0 && (!u || i({ type: 3, focus: 4, id: l }));
  }, [n.comboboxState, u, l]), x(() => {
    if (n.comboboxState !== 0 || !s)
      return;
    let P = k();
    return P.requestAnimationFrame(() => {
      var C, R;
      (R = (C = document.getElementById(l)) == null ? void 0 : C.scrollIntoView) == null || R.call(C, { block: "nearest" });
    }), P.dispose;
  }, [l, s, n.comboboxState, n.activeOptionIndex]);
  let b = (0, import_react3.useCallback)((P) => {
    if (t)
      return P.preventDefault();
    m(), i({ type: 1 }), k().nextFrame(() => {
      var C;
      return (C = n.inputRef.current) == null ? void 0 : C.focus({ preventScroll: true });
    });
  }, [i, n.inputRef, t, m]), T = (0, import_react3.useCallback)(() => {
    if (t)
      return i({ type: 3, focus: 5 });
    i({ type: 3, focus: 4, id: l });
  }, [t, l, i]), y = (0, import_react3.useCallback)(() => {
    t || s || i({ type: 3, focus: 4, id: l });
  }, [t, s, l, i]), p = (0, import_react3.useCallback)(() => {
    t || !s || n.optionsPropsRef.current.hold || i({ type: 3, focus: 5 });
  }, [t, s, i, n.comboboxState, n.comboboxPropsRef]), f = (0, import_react3.useMemo)(() => ({ active: s, selected: u, disabled: t }), [s, u, t]);
  return E({ props: { ...o, ...{ id: l, role: "option", tabIndex: t === true ? void 0 : -1, "aria-disabled": t === true ? true : void 0, "aria-selected": u === true ? true : void 0, disabled: void 0, onClick: b, onFocus: T, onPointerMove: y, onMouseMove: y, onPointerLeave: p, onMouseLeave: p } }, slot: f, defaultTag: Ur, name: "Combobox.Option" });
}
var Na = Object.assign(Ir, { Input: Dr, Button: Fr, Label: kr, Options: Hr, Option: Br });
var Et = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e) => `${e}:not([tabindex='-1'])`).join(",");
function xe(e = document.body) {
  return e == null ? [] : Array.from(e.querySelectorAll(Et));
}
function de(e, t = 0) {
  return e === document.body ? false : S(t, { [0]() {
    return e.matches(Et);
  }, [1]() {
    let r = e;
    for (; r !== null; ) {
      if (r.matches(Et))
        return true;
      r = r.parentElement;
    }
    return false;
  } });
}
function ce(e) {
  e == null || e.focus({ preventScroll: true });
}
function M(e, t) {
  let r = Array.isArray(e) ? e.slice().sort((c, m) => {
    let b = c.compareDocumentPosition(m);
    return b & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : b & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  }) : xe(e), o = document.activeElement, n = (() => {
    if (t & (1 | 4))
      return 1;
    if (t & (2 | 8))
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), i = (() => {
    if (t & 1)
      return 0;
    if (t & 2)
      return Math.max(0, r.indexOf(o)) - 1;
    if (t & 4)
      return Math.max(0, r.indexOf(o)) + 1;
    if (t & 8)
      return r.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), a = t & 32 ? { preventScroll: true } : {}, l = 0, s = r.length, u;
  do {
    if (l >= s || l + s <= 0)
      return 0;
    let c = i + l;
    if (t & 16)
      c = (c + s) % s;
    else {
      if (c < 0)
        return 3;
      if (c >= s)
        return 1;
    }
    u = r[c], u == null || u.focus(a), l += n;
  } while (u !== document.activeElement);
  return u.hasAttribute("tabindex") || u.setAttribute("tabindex", "0"), 2;
}
function Be() {
  let e = (0, import_react18.useRef)(false);
  return (0, import_react18.useEffect)(() => (e.current = true, () => {
    e.current = false;
  }), []), e;
}
function Ne(e, t = 30, { initialFocus: r, containers: o } = {}) {
  let n = (0, import_react17.useRef)(typeof window != "undefined" ? document.activeElement : null), i = (0, import_react17.useRef)(null), a = Be(), l = Boolean(t & 16), s = Boolean(t & 2);
  (0, import_react17.useEffect)(() => {
    !l || (n.current = document.activeElement);
  }, [l]), (0, import_react17.useEffect)(() => {
    if (!!l)
      return () => {
        ce(n.current), n.current = null;
      };
  }, [l]), (0, import_react17.useEffect)(() => {
    if (!s || !e.current)
      return;
    let u = document.activeElement;
    if (r == null ? void 0 : r.current) {
      if ((r == null ? void 0 : r.current) === u) {
        i.current = u;
        return;
      }
    } else if (e.current.contains(u)) {
      i.current = u;
      return;
    }
    (r == null ? void 0 : r.current) ? ce(r.current) : M(e.current, 1) === 0 && console.warn("There are no focusable elements inside the <FocusTrap />"), i.current = document.activeElement;
  }, [e, r, s]), w("keydown", (u) => {
    !(t & 4) || !e.current || u.key === "Tab" && (u.preventDefault(), M(e.current, (u.shiftKey ? 2 : 4) | 16) === 2 && (i.current = document.activeElement));
  }), w("focus", (u) => {
    if (!(t & 8))
      return;
    let c = new Set(o == null ? void 0 : o.current);
    if (c.add(e), !c.size)
      return;
    let m = i.current;
    if (!m || !a.current)
      return;
    let b = u.target;
    b && b instanceof HTMLElement ? Kr(c, b) ? (i.current = b, ce(b)) : (u.preventDefault(), u.stopPropagation(), ce(m)) : ce(i.current);
  }, true);
}
function Kr(e, t) {
  var r;
  for (let o of e)
    if ((r = o.current) == null ? void 0 : r.contains(t))
      return true;
  return false;
}
var fe = /* @__PURE__ */ new Set();
var J = /* @__PURE__ */ new Map();
function po(e) {
  e.setAttribute("aria-hidden", "true"), e.inert = true;
}
function co(e) {
  let t = J.get(e);
  !t || (t["aria-hidden"] === null ? e.removeAttribute("aria-hidden") : e.setAttribute("aria-hidden", t["aria-hidden"]), e.inert = t.inert);
}
function fo(e, t = true) {
  x(() => {
    if (!t || !e.current)
      return;
    let r = e.current;
    fe.add(r);
    for (let o of J.keys())
      o.contains(r) && (co(o), J.delete(o));
    return document.querySelectorAll("body > *").forEach((o) => {
      if (o instanceof HTMLElement) {
        for (let n of fe)
          if (o.contains(n))
            return;
        fe.size === 1 && (J.set(o, { "aria-hidden": o.getAttribute("aria-hidden"), inert: o.inert }), po(o));
      }
    }), () => {
      if (fe.delete(r), fe.size > 0)
        document.querySelectorAll("body > *").forEach((o) => {
          if (o instanceof HTMLElement && !J.has(o)) {
            for (let n of fe)
              if (o.contains(n))
                return;
            J.set(o, { "aria-hidden": o.getAttribute("aria-hidden"), inert: o.inert }), po(o);
          }
        });
      else
        for (let o of J.keys())
          co(o), J.delete(o);
    };
  }, [t]);
}
var mo = (0, import_react20.createContext)(false);
function bo() {
  return (0, import_react20.useContext)(mo);
}
function At(e) {
  return import_react20.default.createElement(mo.Provider, { value: e.force }, e.children);
}
function Xr() {
  let e = bo(), t = (0, import_react19.useContext)(Po), [r, o] = (0, import_react19.useState)(() => {
    if (!e && t !== null || typeof window == "undefined")
      return null;
    let n = document.getElementById("headlessui-portal-root");
    if (n)
      return n;
    let i = document.createElement("div");
    return i.setAttribute("id", "headlessui-portal-root"), document.body.appendChild(i);
  });
  return (0, import_react19.useEffect)(() => {
    r !== null && (document.body.contains(r) || document.body.appendChild(r));
  }, [r]), (0, import_react19.useEffect)(() => {
    e || t !== null && o(t.current);
  }, [t, o, e]), r;
}
var Jr = import_react19.Fragment;
function We(e) {
  let t = e, r = Xr(), [o] = (0, import_react19.useState)(() => typeof window == "undefined" ? null : document.createElement("div")), n = q();
  return x(() => {
    if (!!r && !!o)
      return r.appendChild(o), () => {
        var i;
        !r || !o || (r.removeChild(o), r.childNodes.length <= 0 && ((i = r.parentElement) == null || i.removeChild(r)));
      };
  }, [r, o]), n ? !r || !o ? null : (0, import_react_dom.createPortal)(E({ props: t, defaultTag: Jr, name: "Portal" }), o) : null;
}
var Zr = import_react19.Fragment;
var Po = (0, import_react19.createContext)(null);
function en(e) {
  let { target: t, ...r } = e;
  return import_react19.default.createElement(Po.Provider, { value: t }, E({ props: r, defaultTag: Zr, name: "Popover.Group" }));
}
We.Group = en;
var vo = (0, import_react21.createContext)(null);
function Ro() {
  let e = (0, import_react21.useContext)(vo);
  if (e === null) {
    let t = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t, Ro), t;
  }
  return e;
}
function re() {
  let [e, t] = (0, import_react21.useState)([]);
  return [e.length > 0 ? e.join(" ") : void 0, (0, import_react21.useMemo)(() => function(o) {
    let n = (0, import_react21.useCallback)((a) => (t((l) => [...l, a]), () => t((l) => {
      let s = l.slice(), u = s.indexOf(a);
      return u !== -1 && s.splice(u, 1), s;
    })), []), i = (0, import_react21.useMemo)(() => ({ register: n, slot: o.slot, name: o.name, props: o.props }), [n, o.slot, o.name, o.props]);
    return import_react21.default.createElement(vo.Provider, { value: i }, o.children);
  }, [t])];
}
var an = "p";
function me(e) {
  let t = Ro(), r = `headlessui-description-${A()}`;
  x(() => t.register(r), [r, t.register]);
  let o = e, n = { ...t.props, id: r };
  return E({ props: { ...o, ...n }, slot: t.slot || {}, defaultTag: an, name: t.name || "Description" });
}
var ht = (0, import_react22.createContext)(() => {
});
ht.displayName = "StackContext";
function cn() {
  return (0, import_react22.useContext)(ht);
}
function Eo({ children: e, onUpdate: t, type: r, element: o }) {
  let n = cn(), i = (0, import_react22.useCallback)((...a) => {
    t == null || t(...a), n(...a);
  }, [n, t]);
  return x(() => (i(0, r, o), () => i(1, r, o)), [i, r, o]), import_react22.default.createElement(ht.Provider, { value: i }, e);
}
var yn = { [0](e, t) {
  return e.titleId === t.id ? e : { ...e, titleId: t.id };
} };
var Ve = (0, import_react16.createContext)(null);
Ve.displayName = "DialogContext";
function It(e) {
  let t = (0, import_react16.useContext)(Ve);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${An.displayName} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, It), r;
  }
  return t;
}
function gn(e, t) {
  return S(t.type, yn, e, t);
}
var Pn = "div";
var xn = 1 | 2;
var vn = D(function(t, r) {
  let { open: o, onClose: n, initialFocus: i, ...a } = t, [l, s] = (0, import_react16.useState)(0), u = _();
  o === void 0 && u !== null && (o = S(u, { [0]: true, [1]: false }));
  let c = (0, import_react16.useRef)(/* @__PURE__ */ new Set()), m = (0, import_react16.useRef)(null), b = I(m, r), T = t.hasOwnProperty("open") || u !== null, y = t.hasOwnProperty("onClose");
  if (!T && !y)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!T)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!y)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof o != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${o}`);
  if (typeof n != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${n}`);
  let p = o ? 0 : 1, f = (() => u !== null ? u === 0 : p === 0)(), [d, P] = (0, import_react16.useReducer)(gn, { titleId: null, descriptionId: null }), C = (0, import_react16.useCallback)(() => n(false), [n]), R = (0, import_react16.useCallback)((F) => P({ type: 0, id: F }), [P]), v = q() && p === 0, h = l > 1, O = (0, import_react16.useContext)(Ve) !== null;
  Ne(m, v ? S(h ? "parent" : "leaf", { parent: 16, leaf: 30 }) : 1, { initialFocus: i, containers: c }), fo(m, h ? v : false), w("mousedown", (F) => {
    var H;
    let $ = F.target;
    p === 0 && (h || ((H = m.current) == null ? void 0 : H.contains($)) || C());
  }), w("keydown", (F) => {
    F.key === "Escape" && p === 0 && (h || (F.preventDefault(), F.stopPropagation(), C()));
  }), (0, import_react16.useEffect)(() => {
    if (p !== 0 || O)
      return;
    let F = document.documentElement.style.overflow, $ = document.documentElement.style.paddingRight, H = window.innerWidth - document.documentElement.clientWidth;
    return document.documentElement.style.overflow = "hidden", document.documentElement.style.paddingRight = `${H}px`, () => {
      document.documentElement.style.overflow = F, document.documentElement.style.paddingRight = $;
    };
  }, [p, O]), (0, import_react16.useEffect)(() => {
    if (p !== 0 || !m.current)
      return;
    let F = new IntersectionObserver(($) => {
      for (let H of $)
        H.boundingClientRect.x === 0 && H.boundingClientRect.y === 0 && H.boundingClientRect.width === 0 && H.boundingClientRect.height === 0 && C();
    });
    return F.observe(m.current), () => F.disconnect();
  }, [p, m, C]);
  let [N, K] = re(), V = `headlessui-dialog-${A()}`, Fe = (0, import_react16.useMemo)(() => [{ dialogState: p, close: C, setTitleId: R }, d], [p, d, C, R]), ge = (0, import_react16.useMemo)(() => ({ open: p === 0 }), [p]), we = { ref: b, id: V, role: "dialog", "aria-modal": p === 0 ? true : void 0, "aria-labelledby": d.titleId, "aria-describedby": N, onClick(F) {
    F.stopPropagation();
  } }, X = a;
  return import_react16.default.createElement(Eo, { type: "Dialog", element: m, onUpdate: (0, import_react16.useCallback)((F, $, H) => {
    $ === "Dialog" && S(F, { [0]() {
      c.current.add(H), s((Pe) => Pe + 1);
    }, [1]() {
      c.current.add(H), s((Pe) => Pe - 1);
    } });
  }, []) }, import_react16.default.createElement(At, { force: true }, import_react16.default.createElement(We, null, import_react16.default.createElement(Ve.Provider, { value: Fe }, import_react16.default.createElement(We.Group, { target: m }, import_react16.default.createElement(At, { force: false }, import_react16.default.createElement(K, { slot: ge, name: "Dialog.Description" }, E({ props: { ...X, ...we }, slot: ge, defaultTag: Pn, features: xn, visible: f, name: "Dialog" }))))))));
});
var Rn = "div";
var En = D(function(t, r) {
  let [{ dialogState: o, close: n }] = It("Dialog.Overlay"), i = I(r), a = `headlessui-dialog-overlay-${A()}`, l = (0, import_react16.useCallback)((m) => {
    if (m.target === m.currentTarget) {
      if (G(m.currentTarget))
        return m.preventDefault();
      m.preventDefault(), m.stopPropagation(), n();
    }
  }, [n]), s = (0, import_react16.useMemo)(() => ({ open: o === 0 }), [o]);
  return E({ props: { ...t, ...{ ref: i, id: a, "aria-hidden": true, onClick: l } }, slot: s, defaultTag: Rn, name: "Dialog.Overlay" });
});
var Cn = "h2";
function Sn(e) {
  let [{ dialogState: t, setTitleId: r }] = It("Dialog.Title"), o = `headlessui-dialog-title-${A()}`;
  (0, import_react16.useEffect)(() => (r(o), () => r(null)), [o, r]);
  let n = (0, import_react16.useMemo)(() => ({ open: t === 0 }), [t]);
  return E({ props: { ...e, ...{ id: o } }, slot: n, defaultTag: Cn, name: "Dialog.Title" });
}
var An = Object.assign(vn, { Overlay: En, Title: Sn, Description: me });
var Ln = { [0]: (e) => ({ ...e, disclosureState: S(e.disclosureState, { [0]: 1, [1]: 0 }) }), [1]: (e) => e.disclosureState === 1 ? e : { ...e, disclosureState: 1 }, [4](e) {
  return e.linkedPanel === true ? e : { ...e, linkedPanel: true };
}, [5](e) {
  return e.linkedPanel === false ? e : { ...e, linkedPanel: false };
}, [2](e, t) {
  return e.buttonId === t.buttonId ? e : { ...e, buttonId: t.buttonId };
}, [3](e, t) {
  return e.panelId === t.panelId ? e : { ...e, panelId: t.panelId };
} };
var Mt = (0, import_react23.createContext)(null);
Mt.displayName = "DisclosureContext";
function Ft(e) {
  let t = (0, import_react23.useContext)(Mt);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${Ye.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Ft), r;
  }
  return t;
}
var wt = (0, import_react23.createContext)(null);
wt.displayName = "DisclosureAPIContext";
function Ao(e) {
  let t = (0, import_react23.useContext)(wt);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${Ye.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Ao), r;
  }
  return t;
}
var kt = (0, import_react23.createContext)(null);
kt.displayName = "DisclosurePanelContext";
function Dn() {
  return (0, import_react23.useContext)(kt);
}
function Mn(e, t) {
  return S(t.type, Ln, e, t);
}
var Fn = import_react23.Fragment;
function Ye(e) {
  let { defaultOpen: t = false, ...r } = e, o = `headlessui-disclosure-button-${A()}`, n = `headlessui-disclosure-panel-${A()}`, i = (0, import_react23.useReducer)(Mn, { disclosureState: t ? 0 : 1, linkedPanel: false, buttonId: o, panelId: n }), [{ disclosureState: a }, l] = i;
  (0, import_react23.useEffect)(() => l({ type: 2, buttonId: o }), [o, l]), (0, import_react23.useEffect)(() => l({ type: 3, panelId: n }), [n, l]);
  let s = (0, import_react23.useCallback)((m) => {
    l({ type: 1 });
    let b = (() => m ? m instanceof HTMLElement ? m : m.current instanceof HTMLElement ? m.current : document.getElementById(o) : document.getElementById(o))();
    b == null || b.focus();
  }, [l, o]), u = (0, import_react23.useMemo)(() => ({ close: s }), [s]), c = (0, import_react23.useMemo)(() => ({ open: a === 0, close: s }), [a, s]);
  return import_react23.default.createElement(Mt.Provider, { value: i }, import_react23.default.createElement(wt.Provider, { value: u }, import_react23.default.createElement(W, { value: S(a, { [0]: 0, [1]: 1 }) }, E({ props: r, slot: c, defaultTag: Fn, name: "Disclosure" }))));
}
var wn = "button";
var kn = D(function(t, r) {
  let [o, n] = Ft("Disclosure.Button"), i = (0, import_react23.useRef)(null), a = I(i, r), l = Dn(), s = l === null ? false : l === o.panelId, u = (0, import_react23.useCallback)((f) => {
    var d;
    if (s) {
      if (o.disclosureState === 1)
        return;
      switch (f.key) {
        case " ":
        case "Enter":
          f.preventDefault(), f.stopPropagation(), n({ type: 0 }), (d = document.getElementById(o.buttonId)) == null || d.focus();
          break;
      }
    } else
      switch (f.key) {
        case " ":
        case "Enter":
          f.preventDefault(), f.stopPropagation(), n({ type: 0 });
          break;
      }
  }, [n, s, o.disclosureState, o.buttonId]), c = (0, import_react23.useCallback)((f) => {
    switch (f.key) {
      case " ":
        f.preventDefault();
        break;
    }
  }, []), m = (0, import_react23.useCallback)((f) => {
    var d;
    G(f.currentTarget) || t.disabled || (s ? (n({ type: 0 }), (d = document.getElementById(o.buttonId)) == null || d.focus()) : n({ type: 0 }));
  }, [n, t.disabled, o.buttonId, s]), b = (0, import_react23.useMemo)(() => ({ open: o.disclosureState === 0 }), [o]), T = U(t, i), y = t, p = s ? { ref: a, type: T, onKeyDown: u, onClick: m } : { ref: a, id: o.buttonId, type: T, "aria-expanded": t.disabled ? void 0 : o.disclosureState === 0, "aria-controls": o.linkedPanel ? o.panelId : void 0, onKeyDown: u, onKeyUp: c, onClick: m };
  return E({ props: { ...y, ...p }, slot: b, defaultTag: wn, name: "Disclosure.Button" });
});
var _n = "div";
var Gn = 1 | 2;
var Hn = D(function(t, r) {
  let [o, n] = Ft("Disclosure.Panel"), { close: i } = Ao("Disclosure.Panel"), a = I(r, () => {
    o.linkedPanel || n({ type: 4 });
  }), l = _(), s = (() => l !== null ? l === 0 : o.disclosureState === 0)();
  (0, import_react23.useEffect)(() => () => n({ type: 5 }), [n]), (0, import_react23.useEffect)(() => {
    var b;
    o.disclosureState === 1 && ((b = t.unmount) != null ? b : true) && n({ type: 5 });
  }, [o.disclosureState, t.unmount, n]);
  let u = (0, import_react23.useMemo)(() => ({ open: o.disclosureState === 0, close: i }), [o, i]), c = { ref: a, id: o.panelId }, m = t;
  return import_react23.default.createElement(kt.Provider, { value: o.panelId }, E({ props: { ...m, ...c }, slot: u, defaultTag: _n, features: Gn, visible: s, name: "Disclosure.Panel" }));
});
Ye.Button = kn;
Ye.Panel = Hn;
var $n = { [1](e) {
  return e.disabled || e.listboxState === 1 ? e : { ...e, activeOptionIndex: null, listboxState: 1 };
}, [0](e) {
  return e.disabled || e.listboxState === 0 ? e : { ...e, listboxState: 0 };
}, [2](e, t) {
  return e.disabled === t.disabled ? e : { ...e, disabled: t.disabled };
}, [3](e, t) {
  return e.orientation === t.orientation ? e : { ...e, orientation: t.orientation };
}, [4](e, t) {
  if (e.disabled || e.listboxState === 1)
    return e;
  let r = ae(t, { resolveItems: () => e.options, resolveActiveIndex: () => e.activeOptionIndex, resolveId: (o) => o.id, resolveDisabled: (o) => o.dataRef.current.disabled });
  return e.searchQuery === "" && e.activeOptionIndex === r ? e : { ...e, searchQuery: "", activeOptionIndex: r };
}, [5]: (e, t) => {
  if (e.disabled || e.listboxState === 1)
    return e;
  let o = e.searchQuery !== "" ? 0 : 1, n = e.searchQuery + t.value.toLowerCase(), a = (e.activeOptionIndex !== null ? e.options.slice(e.activeOptionIndex + o).concat(e.options.slice(0, e.activeOptionIndex + o)) : e.options).find((s) => {
    var u;
    return !s.dataRef.current.disabled && ((u = s.dataRef.current.textValue) == null ? void 0 : u.startsWith(n));
  }), l = a ? e.options.indexOf(a) : -1;
  return l === -1 || l === e.activeOptionIndex ? { ...e, searchQuery: n } : { ...e, searchQuery: n, activeOptionIndex: l };
}, [6](e) {
  return e.disabled || e.listboxState === 1 || e.searchQuery === "" ? e : { ...e, searchQuery: "" };
}, [7]: (e, t) => {
  var n;
  let r = Array.from((n = e.optionsRef.current) == null ? void 0 : n.querySelectorAll('[id^="headlessui-listbox-option-"]')).reduce((i, a, l) => Object.assign(i, { [a.id]: l }), {}), o = [...e.options, { id: t.id, dataRef: t.dataRef }].sort((i, a) => r[i.id] - r[a.id]);
  return { ...e, options: o };
}, [8]: (e, t) => {
  let r = e.options.slice(), o = e.activeOptionIndex !== null ? r[e.activeOptionIndex] : null, n = r.findIndex((i) => i.id === t.id);
  return n !== -1 && r.splice(n, 1), { ...e, options: r, activeOptionIndex: (() => n === e.activeOptionIndex || o === null ? null : r.indexOf(o))() };
} };
var Gt = (0, import_react25.createContext)(null);
Gt.displayName = "ListboxContext";
function Re(e) {
  let t = (0, import_react25.useContext)(Gt);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${Ee.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Re), r;
  }
  return t;
}
function Qn(e, t) {
  return S(t.type, $n, e, t);
}
var qn = import_react25.Fragment;
function Ee(e) {
  let { value: t, onChange: r, disabled: o = false, horizontal: n = false, ...i } = e, a = n ? "horizontal" : "vertical", l = (0, import_react25.useReducer)(Qn, { listboxState: 1, propsRef: { current: { value: t, onChange: r } }, labelRef: (0, import_react25.createRef)(), buttonRef: (0, import_react25.createRef)(), optionsRef: (0, import_react25.createRef)(), disabled: o, orientation: a, options: [], searchQuery: "", activeOptionIndex: null }), [{ listboxState: s, propsRef: u, optionsRef: c, buttonRef: m }, b] = l;
  x(() => {
    u.current.value = t;
  }, [t, u]), x(() => {
    u.current.onChange = r;
  }, [r, u]), x(() => b({ type: 2, disabled: o }), [o]), x(() => b({ type: 3, orientation: a }), [a]), w("mousedown", (y) => {
    var f, d, P;
    let p = y.target;
    s === 0 && (((f = m.current) == null ? void 0 : f.contains(p)) || ((d = c.current) == null ? void 0 : d.contains(p)) || (b({ type: 1 }), de(p, 1) || (y.preventDefault(), (P = m.current) == null || P.focus())));
  });
  let T = (0, import_react25.useMemo)(() => ({ open: s === 0, disabled: o }), [s, o]);
  return import_react25.default.createElement(Gt.Provider, { value: l }, import_react25.default.createElement(W, { value: S(s, { [0]: 0, [1]: 1 }) }, E({ props: i, slot: T, defaultTag: qn, name: "Listbox" })));
}
var zn = "button";
var Yn = D(function(t, r) {
  var p;
  let [o, n] = Re("Listbox.Button"), i = I(o.buttonRef, r), a = `headlessui-listbox-button-${A()}`, l = Q(), s = (0, import_react25.useCallback)((f) => {
    switch (f.key) {
      case " ":
      case "Enter":
      case "ArrowDown":
        f.preventDefault(), n({ type: 0 }), l.nextFrame(() => {
          o.propsRef.current.value || n({ type: 4, focus: 0 });
        });
        break;
      case "ArrowUp":
        f.preventDefault(), n({ type: 0 }), l.nextFrame(() => {
          o.propsRef.current.value || n({ type: 4, focus: 3 });
        });
        break;
    }
  }, [n, o, l]), u = (0, import_react25.useCallback)((f) => {
    switch (f.key) {
      case " ":
        f.preventDefault();
        break;
    }
  }, []), c = (0, import_react25.useCallback)((f) => {
    if (G(f.currentTarget))
      return f.preventDefault();
    o.listboxState === 0 ? (n({ type: 1 }), l.nextFrame(() => {
      var d;
      return (d = o.buttonRef.current) == null ? void 0 : d.focus({ preventScroll: true });
    })) : (f.preventDefault(), n({ type: 0 }));
  }, [n, l, o]), m = ee(() => {
    if (!!o.labelRef.current)
      return [o.labelRef.current.id, a].join(" ");
  }, [o.labelRef.current, a]), b = (0, import_react25.useMemo)(() => ({ open: o.listboxState === 0, disabled: o.disabled }), [o]), T = t, y = { ref: i, id: a, type: U(t, o.buttonRef), "aria-haspopup": true, "aria-controls": (p = o.optionsRef.current) == null ? void 0 : p.id, "aria-expanded": o.disabled ? void 0 : o.listboxState === 0, "aria-labelledby": m, disabled: o.disabled, onKeyDown: s, onKeyUp: u, onClick: c };
  return E({ props: { ...T, ...y }, slot: b, defaultTag: zn, name: "Listbox.Button" });
});
var Xn = "label";
function Jn(e) {
  let [t] = Re("Listbox.Label"), r = `headlessui-listbox-label-${A()}`, o = (0, import_react25.useCallback)(() => {
    var a;
    return (a = t.buttonRef.current) == null ? void 0 : a.focus({ preventScroll: true });
  }, [t.buttonRef]), n = (0, import_react25.useMemo)(() => ({ open: t.listboxState === 0, disabled: t.disabled }), [t]), i = { ref: t.labelRef, id: r, onClick: o };
  return E({ props: { ...e, ...i }, slot: n, defaultTag: Xn, name: "Listbox.Label" });
}
var Zn = "ul";
var ei = 1 | 2;
var ti = D(function(t, r) {
  var f;
  let [o, n] = Re("Listbox.Options"), i = I(o.optionsRef, r), a = `headlessui-listbox-options-${A()}`, l = Q(), s = Q(), u = _(), c = (() => u !== null ? u === 0 : o.listboxState === 0)();
  x(() => {
    let d = o.optionsRef.current;
    !d || o.listboxState === 0 && d !== document.activeElement && d.focus({ preventScroll: true });
  }, [o.listboxState, o.optionsRef]);
  let m = (0, import_react25.useCallback)((d) => {
    switch (s.dispose(), d.key) {
      case " ":
        if (o.searchQuery !== "")
          return d.preventDefault(), d.stopPropagation(), n({ type: 5, value: d.key });
      case "Enter":
        if (d.preventDefault(), d.stopPropagation(), n({ type: 1 }), o.activeOptionIndex !== null) {
          let { dataRef: P } = o.options[o.activeOptionIndex];
          o.propsRef.current.onChange(P.current.value);
        }
        k().nextFrame(() => {
          var P;
          return (P = o.buttonRef.current) == null ? void 0 : P.focus({ preventScroll: true });
        });
        break;
      case S(o.orientation, { vertical: "ArrowDown", horizontal: "ArrowRight" }):
        return d.preventDefault(), d.stopPropagation(), n({ type: 4, focus: 2 });
      case S(o.orientation, { vertical: "ArrowUp", horizontal: "ArrowLeft" }):
        return d.preventDefault(), d.stopPropagation(), n({ type: 4, focus: 1 });
      case "Home":
      case "PageUp":
        return d.preventDefault(), d.stopPropagation(), n({ type: 4, focus: 0 });
      case "End":
      case "PageDown":
        return d.preventDefault(), d.stopPropagation(), n({ type: 4, focus: 3 });
      case "Escape":
        return d.preventDefault(), d.stopPropagation(), n({ type: 1 }), l.nextFrame(() => {
          var P;
          return (P = o.buttonRef.current) == null ? void 0 : P.focus({ preventScroll: true });
        });
      case "Tab":
        d.preventDefault(), d.stopPropagation();
        break;
      default:
        d.key.length === 1 && (n({ type: 5, value: d.key }), s.setTimeout(() => n({ type: 6 }), 350));
        break;
    }
  }, [l, n, s, o]), b = ee(() => {
    var d, P, C;
    return (C = (d = o.labelRef.current) == null ? void 0 : d.id) != null ? C : (P = o.buttonRef.current) == null ? void 0 : P.id;
  }, [o.labelRef.current, o.buttonRef.current]), T = (0, import_react25.useMemo)(() => ({ open: o.listboxState === 0 }), [o]), y = { "aria-activedescendant": o.activeOptionIndex === null || (f = o.options[o.activeOptionIndex]) == null ? void 0 : f.id, "aria-labelledby": b, "aria-orientation": o.orientation, id: a, onKeyDown: m, role: "listbox", tabIndex: 0, ref: i };
  return E({ props: { ...t, ...y }, slot: T, defaultTag: Zn, features: ei, visible: c, name: "Listbox.Options" });
});
var oi = "li";
function ri(e) {
  let { disabled: t = false, value: r, ...o } = e, [n, i] = Re("Listbox.Option"), a = `headlessui-listbox-option-${A()}`, l = n.activeOptionIndex !== null ? n.options[n.activeOptionIndex].id === a : false, s = n.propsRef.current.value === r, u = (0, import_react25.useRef)({ disabled: t, value: r });
  x(() => {
    u.current.disabled = t;
  }, [u, t]), x(() => {
    u.current.value = r;
  }, [u, r]), x(() => {
    var d, P;
    u.current.textValue = (P = (d = document.getElementById(a)) == null ? void 0 : d.textContent) == null ? void 0 : P.toLowerCase();
  }, [u, a]);
  let c = (0, import_react25.useCallback)(() => n.propsRef.current.onChange(r), [n.propsRef, r]);
  x(() => (i({ type: 7, id: a, dataRef: u }), () => i({ type: 8, id: a })), [u, a]), x(() => {
    var d, P;
    n.listboxState === 0 && (!s || (i({ type: 4, focus: 4, id: a }), (P = (d = document.getElementById(a)) == null ? void 0 : d.focus) == null || P.call(d)));
  }, [n.listboxState]), x(() => {
    if (n.listboxState !== 0 || !l)
      return;
    let d = k();
    return d.requestAnimationFrame(() => {
      var P, C;
      (C = (P = document.getElementById(a)) == null ? void 0 : P.scrollIntoView) == null || C.call(P, { block: "nearest" });
    }), d.dispose;
  }, [a, l, n.listboxState, n.activeOptionIndex]);
  let m = (0, import_react25.useCallback)((d) => {
    if (t)
      return d.preventDefault();
    c(), i({ type: 1 }), k().nextFrame(() => {
      var P;
      return (P = n.buttonRef.current) == null ? void 0 : P.focus({ preventScroll: true });
    });
  }, [i, n.buttonRef, t, c]), b = (0, import_react25.useCallback)(() => {
    if (t)
      return i({ type: 4, focus: 5 });
    i({ type: 4, focus: 4, id: a });
  }, [t, a, i]), T = (0, import_react25.useCallback)(() => {
    t || l || i({ type: 4, focus: 4, id: a });
  }, [t, l, a, i]), y = (0, import_react25.useCallback)(() => {
    t || !l || i({ type: 4, focus: 5 });
  }, [t, l, i]), p = (0, import_react25.useMemo)(() => ({ active: l, selected: s, disabled: t }), [l, s, t]);
  return E({ props: { ...o, ...{ id: a, role: "option", tabIndex: t === true ? void 0 : -1, "aria-disabled": t === true ? true : void 0, "aria-selected": s === true ? true : void 0, disabled: void 0, onClick: m, onFocus: b, onPointerMove: T, onMouseMove: T, onPointerLeave: y, onMouseLeave: y } }, slot: p, defaultTag: oi, name: "Listbox.Option" });
}
Ee.Button = Yn;
Ee.Label = Jn;
Ee.Options = ti;
Ee.Option = ri;
var ui = { [1](e) {
  return e.menuState === 1 ? e : { ...e, activeItemIndex: null, menuState: 1 };
}, [0](e) {
  return e.menuState === 0 ? e : { ...e, menuState: 0 };
}, [2]: (e, t) => {
  let r = ae(t, { resolveItems: () => e.items, resolveActiveIndex: () => e.activeItemIndex, resolveId: (o) => o.id, resolveDisabled: (o) => o.dataRef.current.disabled });
  return e.searchQuery === "" && e.activeItemIndex === r ? e : { ...e, searchQuery: "", activeItemIndex: r };
}, [3]: (e, t) => {
  let o = e.searchQuery !== "" ? 0 : 1, n = e.searchQuery + t.value.toLowerCase(), a = (e.activeItemIndex !== null ? e.items.slice(e.activeItemIndex + o).concat(e.items.slice(0, e.activeItemIndex + o)) : e.items).find((s) => {
    var u;
    return ((u = s.dataRef.current.textValue) == null ? void 0 : u.startsWith(n)) && !s.dataRef.current.disabled;
  }), l = a ? e.items.indexOf(a) : -1;
  return l === -1 || l === e.activeItemIndex ? { ...e, searchQuery: n } : { ...e, searchQuery: n, activeItemIndex: l };
}, [4](e) {
  return e.searchQuery === "" ? e : { ...e, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e, t) => {
  var n;
  let r = Array.from((n = e.itemsRef.current) == null ? void 0 : n.querySelectorAll('[id^="headlessui-menu-item-"]')).reduce((i, a, l) => Object.assign(i, { [a.id]: l }), {}), o = [...e.items, { id: t.id, dataRef: t.dataRef }].sort((i, a) => r[i.id] - r[a.id]);
  return { ...e, items: o };
}, [6]: (e, t) => {
  let r = e.items.slice(), o = e.activeItemIndex !== null ? r[e.activeItemIndex] : null, n = r.findIndex((i) => i.id === t.id);
  return n !== -1 && r.splice(n, 1), { ...e, items: r, activeItemIndex: (() => n === e.activeItemIndex || o === null ? null : r.indexOf(o))() };
} };
var Ht = (0, import_react26.createContext)(null);
Ht.displayName = "MenuContext";
function Je(e) {
  let t = (0, import_react26.useContext)(Ht);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${Ze.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Je), r;
  }
  return t;
}
function pi(e, t) {
  return S(t.type, ui, e, t);
}
var di = import_react26.Fragment;
function Ze(e) {
  let t = (0, import_react26.useReducer)(pi, { menuState: 1, buttonRef: (0, import_react26.createRef)(), itemsRef: (0, import_react26.createRef)(), items: [], searchQuery: "", activeItemIndex: null }), [{ menuState: r, itemsRef: o, buttonRef: n }, i] = t;
  w("mousedown", (l) => {
    var u, c, m;
    let s = l.target;
    r === 0 && (((u = n.current) == null ? void 0 : u.contains(s)) || ((c = o.current) == null ? void 0 : c.contains(s)) || (i({ type: 1 }), de(s, 1) || (l.preventDefault(), (m = n.current) == null || m.focus())));
  });
  let a = (0, import_react26.useMemo)(() => ({ open: r === 0 }), [r]);
  return import_react26.default.createElement(Ht.Provider, { value: t }, import_react26.default.createElement(W, { value: S(r, { [0]: 0, [1]: 1 }) }, E({ props: e, slot: a, defaultTag: di, name: "Menu" })));
}
var ci = "button";
var fi = D(function(t, r) {
  var y;
  let [o, n] = Je("Menu.Button"), i = I(o.buttonRef, r), a = `headlessui-menu-button-${A()}`, l = Q(), s = (0, import_react26.useCallback)((p) => {
    switch (p.key) {
      case " ":
      case "Enter":
      case "ArrowDown":
        p.preventDefault(), p.stopPropagation(), n({ type: 0 }), l.nextFrame(() => n({ type: 2, focus: 0 }));
        break;
      case "ArrowUp":
        p.preventDefault(), p.stopPropagation(), n({ type: 0 }), l.nextFrame(() => n({ type: 2, focus: 3 }));
        break;
    }
  }, [n, l]), u = (0, import_react26.useCallback)((p) => {
    switch (p.key) {
      case " ":
        p.preventDefault();
        break;
    }
  }, []), c = (0, import_react26.useCallback)((p) => {
    if (G(p.currentTarget))
      return p.preventDefault();
    t.disabled || (o.menuState === 0 ? (n({ type: 1 }), l.nextFrame(() => {
      var f;
      return (f = o.buttonRef.current) == null ? void 0 : f.focus({ preventScroll: true });
    })) : (p.preventDefault(), p.stopPropagation(), n({ type: 0 })));
  }, [n, l, o, t.disabled]), m = (0, import_react26.useMemo)(() => ({ open: o.menuState === 0 }), [o]), b = t, T = { ref: i, id: a, type: U(t, o.buttonRef), "aria-haspopup": true, "aria-controls": (y = o.itemsRef.current) == null ? void 0 : y.id, "aria-expanded": t.disabled ? void 0 : o.menuState === 0, onKeyDown: s, onKeyUp: u, onClick: c };
  return E({ props: { ...b, ...T }, slot: m, defaultTag: ci, name: "Menu.Button" });
});
var mi = "div";
var bi = 1 | 2;
var Ti = D(function(t, r) {
  var p, f;
  let [o, n] = Je("Menu.Items"), i = I(o.itemsRef, r), a = `headlessui-menu-items-${A()}`, l = Q(), s = _(), u = (() => s !== null ? s === 0 : o.menuState === 0)();
  (0, import_react26.useEffect)(() => {
    let d = o.itemsRef.current;
    !d || o.menuState === 0 && d !== document.activeElement && d.focus({ preventScroll: true });
  }, [o.menuState, o.itemsRef]), se({ container: o.itemsRef.current, enabled: o.menuState === 0, accept(d) {
    return d.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : d.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(d) {
    d.setAttribute("role", "none");
  } });
  let c = (0, import_react26.useCallback)((d) => {
    var P;
    switch (l.dispose(), d.key) {
      case " ":
        if (o.searchQuery !== "")
          return d.preventDefault(), d.stopPropagation(), n({ type: 3, value: d.key });
      case "Enter":
        if (d.preventDefault(), d.stopPropagation(), n({ type: 1 }), o.activeItemIndex !== null) {
          let { id: C } = o.items[o.activeItemIndex];
          (P = document.getElementById(C)) == null || P.click();
        }
        k().nextFrame(() => {
          var C;
          return (C = o.buttonRef.current) == null ? void 0 : C.focus({ preventScroll: true });
        });
        break;
      case "ArrowDown":
        return d.preventDefault(), d.stopPropagation(), n({ type: 2, focus: 2 });
      case "ArrowUp":
        return d.preventDefault(), d.stopPropagation(), n({ type: 2, focus: 1 });
      case "Home":
      case "PageUp":
        return d.preventDefault(), d.stopPropagation(), n({ type: 2, focus: 0 });
      case "End":
      case "PageDown":
        return d.preventDefault(), d.stopPropagation(), n({ type: 2, focus: 3 });
      case "Escape":
        d.preventDefault(), d.stopPropagation(), n({ type: 1 }), k().nextFrame(() => {
          var C;
          return (C = o.buttonRef.current) == null ? void 0 : C.focus({ preventScroll: true });
        });
        break;
      case "Tab":
        d.preventDefault(), d.stopPropagation();
        break;
      default:
        d.key.length === 1 && (n({ type: 3, value: d.key }), l.setTimeout(() => n({ type: 4 }), 350));
        break;
    }
  }, [n, l, o]), m = (0, import_react26.useCallback)((d) => {
    switch (d.key) {
      case " ":
        d.preventDefault();
        break;
    }
  }, []), b = (0, import_react26.useMemo)(() => ({ open: o.menuState === 0 }), [o]), T = { "aria-activedescendant": o.activeItemIndex === null || (p = o.items[o.activeItemIndex]) == null ? void 0 : p.id, "aria-labelledby": (f = o.buttonRef.current) == null ? void 0 : f.id, id: a, onKeyDown: c, onKeyUp: m, role: "menu", tabIndex: 0, ref: i };
  return E({ props: { ...t, ...T }, slot: b, defaultTag: mi, features: bi, visible: u, name: "Menu.Items" });
});
var yi = import_react26.Fragment;
function gi(e) {
  let { disabled: t = false, onClick: r, ...o } = e, [n, i] = Je("Menu.Item"), a = `headlessui-menu-item-${A()}`, l = n.activeItemIndex !== null ? n.items[n.activeItemIndex].id === a : false;
  x(() => {
    if (n.menuState !== 0 || !l)
      return;
    let p = k();
    return p.requestAnimationFrame(() => {
      var f, d;
      (d = (f = document.getElementById(a)) == null ? void 0 : f.scrollIntoView) == null || d.call(f, { block: "nearest" });
    }), p.dispose;
  }, [a, l, n.menuState, n.activeItemIndex]);
  let s = (0, import_react26.useRef)({ disabled: t });
  x(() => {
    s.current.disabled = t;
  }, [s, t]), x(() => {
    var p, f;
    s.current.textValue = (f = (p = document.getElementById(a)) == null ? void 0 : p.textContent) == null ? void 0 : f.toLowerCase();
  }, [s, a]), x(() => (i({ type: 5, id: a, dataRef: s }), () => i({ type: 6, id: a })), [s, a]);
  let u = (0, import_react26.useCallback)((p) => {
    if (t)
      return p.preventDefault();
    if (i({ type: 1 }), k().nextFrame(() => {
      var f;
      return (f = n.buttonRef.current) == null ? void 0 : f.focus({ preventScroll: true });
    }), r)
      return r(p);
  }, [i, n.buttonRef, t, r]), c = (0, import_react26.useCallback)(() => {
    if (t)
      return i({ type: 2, focus: 5 });
    i({ type: 2, focus: 4, id: a });
  }, [t, a, i]), m = (0, import_react26.useCallback)(() => {
    t || l || i({ type: 2, focus: 4, id: a });
  }, [t, l, a, i]), b = (0, import_react26.useCallback)(() => {
    t || !l || i({ type: 2, focus: 5 });
  }, [t, l, i]), T = (0, import_react26.useMemo)(() => ({ active: l, disabled: t }), [l, t]);
  return E({ props: { ...o, ...{ id: a, role: "menuitem", tabIndex: t === true ? void 0 : -1, "aria-disabled": t === true ? true : void 0, disabled: void 0, onClick: u, onFocus: c, onPointerMove: m, onMouseMove: m, onPointerLeave: b, onMouseLeave: b } }, slot: T, defaultTag: yi, name: "Menu.Item" });
}
Ze.Button = fi;
Ze.Items = Ti;
Ze.Item = gi;
var vi = { [0]: (e) => ({ ...e, popoverState: S(e.popoverState, { [0]: 1, [1]: 0 }) }), [1](e) {
  return e.popoverState === 1 ? e : { ...e, popoverState: 1 };
}, [2](e, t) {
  return e.button === t.button ? e : { ...e, button: t.button };
}, [3](e, t) {
  return e.buttonId === t.buttonId ? e : { ...e, buttonId: t.buttonId };
}, [4](e, t) {
  return e.panel === t.panel ? e : { ...e, panel: t.panel };
}, [5](e, t) {
  return e.panelId === t.panelId ? e : { ...e, panelId: t.panelId };
} };
var Ut = (0, import_react27.createContext)(null);
Ut.displayName = "PopoverContext";
function ot(e) {
  let t = (0, import_react27.useContext)(Ut);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${Te.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, ot), r;
  }
  return t;
}
var Bt = (0, import_react27.createContext)(null);
Bt.displayName = "PopoverAPIContext";
function Mo(e) {
  let t = (0, import_react27.useContext)(Bt);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${Te.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Mo), r;
  }
  return t;
}
var Nt = (0, import_react27.createContext)(null);
Nt.displayName = "PopoverGroupContext";
function Fo() {
  return (0, import_react27.useContext)(Nt);
}
var Wt = (0, import_react27.createContext)(null);
Wt.displayName = "PopoverPanelContext";
function Ri() {
  return (0, import_react27.useContext)(Wt);
}
function Ei(e, t) {
  return S(t.type, vi, e, t);
}
var Ci = "div";
function Te(e) {
  let t = `headlessui-popover-button-${A()}`, r = `headlessui-popover-panel-${A()}`, o = (0, import_react27.useReducer)(Ei, { popoverState: 1, button: null, buttonId: t, panel: null, panelId: r }), [{ popoverState: n, button: i, panel: a }, l] = o;
  (0, import_react27.useEffect)(() => l({ type: 3, buttonId: t }), [t, l]), (0, import_react27.useEffect)(() => l({ type: 5, panelId: r }), [r, l]);
  let s = (0, import_react27.useMemo)(() => ({ buttonId: t, panelId: r, close: () => l({ type: 1 }) }), [t, r, l]), u = Fo(), c = u == null ? void 0 : u.registerPopover, m = (0, import_react27.useCallback)(() => {
    var p;
    return (p = u == null ? void 0 : u.isFocusWithinPopoverGroup()) != null ? p : (i == null ? void 0 : i.contains(document.activeElement)) || (a == null ? void 0 : a.contains(document.activeElement));
  }, [u, i, a]);
  (0, import_react27.useEffect)(() => c == null ? void 0 : c(s), [c, s]), w("focus", () => {
    n === 0 && (m() || !i || !a || l({ type: 1 }));
  }, true), w("mousedown", (p) => {
    let f = p.target;
    n === 0 && ((i == null ? void 0 : i.contains(f)) || (a == null ? void 0 : a.contains(f)) || (l({ type: 1 }), de(f, 1) || (p.preventDefault(), i == null || i.focus())));
  });
  let b = (0, import_react27.useCallback)((p) => {
    l({ type: 1 });
    let f = (() => p ? p instanceof HTMLElement ? p : p.current instanceof HTMLElement ? p.current : i : i)();
    f == null || f.focus();
  }, [l, i]), T = (0, import_react27.useMemo)(() => ({ close: b }), [b]), y = (0, import_react27.useMemo)(() => ({ open: n === 0, close: b }), [n, b]);
  return import_react27.default.createElement(Ut.Provider, { value: o }, import_react27.default.createElement(Bt.Provider, { value: T }, import_react27.default.createElement(W, { value: S(n, { [0]: 0, [1]: 1 }) }, E({ props: e, slot: y, defaultTag: Ci, name: "Popover" }))));
}
var Si = "button";
var Ai = D(function(t, r) {
  let [o, n] = ot("Popover.Button"), i = (0, import_react27.useRef)(null), a = Fo(), l = a == null ? void 0 : a.closeOthers, s = Ri(), u = s === null ? false : s === o.panelId, c = I(i, r, u ? null : (g) => n({ type: 2, button: g })), m = I(i, r), b = (0, import_react27.useRef)(null), T = (0, import_react27.useRef)(typeof window == "undefined" ? null : document.activeElement);
  w("focus", () => {
    T.current = b.current, b.current = document.activeElement;
  }, true);
  let y = (0, import_react27.useCallback)((g) => {
    var v, h;
    if (u) {
      if (o.popoverState === 1)
        return;
      switch (g.key) {
        case " ":
        case "Enter":
          g.preventDefault(), g.stopPropagation(), n({ type: 1 }), (v = o.button) == null || v.focus();
          break;
      }
    } else
      switch (g.key) {
        case " ":
        case "Enter":
          g.preventDefault(), g.stopPropagation(), o.popoverState === 1 && (l == null || l(o.buttonId)), n({ type: 0 });
          break;
        case "Escape":
          if (o.popoverState !== 0)
            return l == null ? void 0 : l(o.buttonId);
          if (!i.current || !i.current.contains(document.activeElement))
            return;
          g.preventDefault(), g.stopPropagation(), n({ type: 1 });
          break;
        case "Tab":
          if (o.popoverState !== 0 || !o.panel || !o.button)
            return;
          if (g.shiftKey) {
            if (!T.current || ((h = o.button) == null ? void 0 : h.contains(T.current)) || o.panel.contains(T.current))
              return;
            let O = xe(), L = O.indexOf(T.current);
            if (O.indexOf(o.button) > L)
              return;
            g.preventDefault(), g.stopPropagation(), M(o.panel, 8);
          } else
            g.preventDefault(), g.stopPropagation(), M(o.panel, 1);
          break;
      }
  }, [n, o.popoverState, o.buttonId, o.button, o.panel, i, l, u]), p = (0, import_react27.useCallback)((g) => {
    var v;
    if (!u && (g.key === " " && g.preventDefault(), o.popoverState === 0 && !!o.panel && !!o.button))
      switch (g.key) {
        case "Tab":
          if (!T.current || ((v = o.button) == null ? void 0 : v.contains(T.current)) || o.panel.contains(T.current))
            return;
          let h = xe(), O = h.indexOf(T.current);
          if (h.indexOf(o.button) > O)
            return;
          g.preventDefault(), g.stopPropagation(), M(o.panel, 8);
          break;
      }
  }, [o.popoverState, o.panel, o.button, u]), f = (0, import_react27.useCallback)((g) => {
    var v, h;
    G(g.currentTarget) || t.disabled || (u ? (n({ type: 1 }), (v = o.button) == null || v.focus()) : (o.popoverState === 1 && (l == null || l(o.buttonId)), (h = o.button) == null || h.focus(), n({ type: 0 })));
  }, [n, o.button, o.popoverState, o.buttonId, t.disabled, l, u]), d = (0, import_react27.useMemo)(() => ({ open: o.popoverState === 0 }), [o]), P = U(t, i), C = t, R = u ? { ref: m, type: P, onKeyDown: y, onClick: f } : { ref: c, id: o.buttonId, type: P, "aria-expanded": t.disabled ? void 0 : o.popoverState === 0, "aria-controls": o.panel ? o.panelId : void 0, onKeyDown: y, onKeyUp: p, onClick: f };
  return E({ props: { ...C, ...R }, slot: d, defaultTag: Si, name: "Popover.Button" });
});
var hi = "div";
var Oi = 1 | 2;
var Ii = D(function(t, r) {
  let [{ popoverState: o }, n] = ot("Popover.Overlay"), i = I(r), a = `headlessui-popover-overlay-${A()}`, l = _(), s = (() => l !== null ? l === 0 : o === 0)(), u = (0, import_react27.useCallback)((T) => {
    if (G(T.currentTarget))
      return T.preventDefault();
    n({ type: 1 });
  }, [n]), c = (0, import_react27.useMemo)(() => ({ open: o === 0 }), [o]);
  return E({ props: { ...t, ...{ ref: i, id: a, "aria-hidden": true, onClick: u } }, slot: c, defaultTag: hi, features: Oi, visible: s, name: "Popover.Overlay" });
});
var Li = "div";
var Di = 1 | 2;
var Mi = D(function(t, r) {
  let { focus: o = false, ...n } = t, [i, a] = ot("Popover.Panel"), { close: l } = Mo("Popover.Panel"), s = (0, import_react27.useRef)(null), u = I(s, r, (p) => {
    a({ type: 4, panel: p });
  }), c = _(), m = (() => c !== null ? c === 0 : i.popoverState === 0)(), b = (0, import_react27.useCallback)((p) => {
    var f;
    switch (p.key) {
      case "Escape":
        if (i.popoverState !== 0 || !s.current || !s.current.contains(document.activeElement))
          return;
        p.preventDefault(), p.stopPropagation(), a({ type: 1 }), (f = i.button) == null || f.focus();
        break;
    }
  }, [i, s, a]);
  (0, import_react27.useEffect)(() => () => a({ type: 4, panel: null }), [a]), (0, import_react27.useEffect)(() => {
    var p;
    t.static || i.popoverState === 1 && ((p = t.unmount) != null ? p : true) && a({ type: 4, panel: null });
  }, [i.popoverState, t.unmount, t.static, a]), (0, import_react27.useEffect)(() => {
    if (!o || i.popoverState !== 0 || !s.current)
      return;
    let p = document.activeElement;
    s.current.contains(p) || M(s.current, 1);
  }, [o, s, i.popoverState]), w("keydown", (p) => {
    var d;
    if (i.popoverState !== 0 || !s.current || p.key !== "Tab" || !document.activeElement || !s.current || !s.current.contains(document.activeElement))
      return;
    p.preventDefault();
    let f = M(s.current, p.shiftKey ? 2 : 4);
    if (f === 3)
      return (d = i.button) == null ? void 0 : d.focus();
    if (f === 1) {
      if (!i.button)
        return;
      let P = xe(), C = P.indexOf(i.button), R = P.splice(C + 1).filter((g) => {
        var v;
        return !((v = s.current) == null ? void 0 : v.contains(g));
      });
      M(R, 1) === 0 && M(document.body, 1);
    }
  }), w("focus", () => {
    var p;
    !o || i.popoverState === 0 && (!s.current || ((p = s.current) == null ? void 0 : p.contains(document.activeElement)) || a({ type: 1 }));
  }, true);
  let T = (0, import_react27.useMemo)(() => ({ open: i.popoverState === 0, close: l }), [i, l]), y = { ref: u, id: i.panelId, onKeyDown: b };
  return import_react27.default.createElement(Wt.Provider, { value: i.panelId }, E({ props: { ...n, ...y }, slot: T, defaultTag: Li, features: Di, visible: m, name: "Popover.Panel" }));
});
var Fi = "div";
function wi(e) {
  let t = (0, import_react27.useRef)(null), [r, o] = (0, import_react27.useState)([]), n = (0, import_react27.useCallback)((b) => {
    o((T) => {
      let y = T.indexOf(b);
      if (y !== -1) {
        let p = T.slice();
        return p.splice(y, 1), p;
      }
      return T;
    });
  }, [o]), i = (0, import_react27.useCallback)((b) => (o((T) => [...T, b]), () => n(b)), [o, n]), a = (0, import_react27.useCallback)(() => {
    var T;
    let b = document.activeElement;
    return ((T = t.current) == null ? void 0 : T.contains(b)) ? true : r.some((y) => {
      var p, f;
      return ((p = document.getElementById(y.buttonId)) == null ? void 0 : p.contains(b)) || ((f = document.getElementById(y.panelId)) == null ? void 0 : f.contains(b));
    });
  }, [t, r]), l = (0, import_react27.useCallback)((b) => {
    for (let T of r)
      T.buttonId !== b && T.close();
  }, [r]), s = (0, import_react27.useMemo)(() => ({ registerPopover: i, unregisterPopover: n, isFocusWithinPopoverGroup: a, closeOthers: l }), [i, n, a, l]), u = (0, import_react27.useMemo)(() => ({}), []), c = { ref: t }, m = e;
  return import_react27.default.createElement(Nt.Provider, { value: s }, E({ props: { ...m, ...c }, slot: u, defaultTag: Fi, name: "Popover.Group" }));
}
Te.Button = Ai;
Te.Overlay = Ii;
Te.Panel = Mi;
Te.Group = wi;
function wo(e = 0) {
  let [t, r] = (0, import_react29.useState)(e), o = (0, import_react29.useCallback)((l) => r((s) => s | l), [r]), n = (0, import_react29.useCallback)((l) => Boolean(t & l), [t]), i = (0, import_react29.useCallback)((l) => r((s) => s & ~l), [r]), a = (0, import_react29.useCallback)((l) => r((s) => s ^ l), [r]);
  return { addFlag: o, hasFlag: n, removeFlag: i, toggleFlag: a };
}
var _o = (0, import_react30.createContext)(null);
function Go() {
  let e = (0, import_react30.useContext)(_o);
  if (e === null) {
    let t = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t, Go), t;
  }
  return e;
}
function Ae() {
  let [e, t] = (0, import_react30.useState)([]);
  return [e.length > 0 ? e.join(" ") : void 0, (0, import_react30.useMemo)(() => function(o) {
    let n = (0, import_react30.useCallback)((a) => (t((l) => [...l, a]), () => t((l) => {
      let s = l.slice(), u = s.indexOf(a);
      return u !== -1 && s.splice(u, 1), s;
    })), []), i = (0, import_react30.useMemo)(() => ({ register: n, slot: o.slot, name: o.name, props: o.props }), [n, o.slot, o.name, o.props]);
    return import_react30.default.createElement(_o.Provider, { value: i }, o.children);
  }, [t])];
}
var Ni = "label";
function nt(e) {
  let { passive: t = false, ...r } = e, o = Go(), n = `headlessui-label-${A()}`;
  x(() => o.register(n), [n, o.register]);
  let i = { ...o.props, id: n }, a = { ...r, ...i };
  return t && delete a.onClick, E({ props: a, slot: o.slot || {}, defaultTag: Ni, name: o.name || "Label" });
}
var Vi = { [0](e, t) {
  return { ...e, options: [...e.options, { id: t.id, element: t.element, propsRef: t.propsRef }] };
}, [1](e, t) {
  let r = e.options.slice(), o = e.options.findIndex((n) => n.id === t.id);
  return o === -1 ? e : (r.splice(o, 1), { ...e, options: r });
} };
var jt = (0, import_react28.createContext)(null);
jt.displayName = "RadioGroupContext";
function Ho(e) {
  let t = (0, import_react28.useContext)(jt);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <${lt.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Ho), r;
  }
  return t;
}
function $i(e, t) {
  return S(t.type, Vi, e, t);
}
var Qi = "div";
function lt(e) {
  let { value: t, onChange: r, disabled: o = false, ...n } = e, [{ options: i }, a] = (0, import_react28.useReducer)($i, { options: [] }), [l, s] = Ae(), [u, c] = re(), m = `headlessui-radiogroup-${A()}`, b = (0, import_react28.useRef)(null), T = (0, import_react28.useMemo)(() => i.find((R) => !R.propsRef.current.disabled), [i]), y = (0, import_react28.useMemo)(() => i.some((R) => R.propsRef.current.value === t), [i, t]), p = (0, import_react28.useCallback)((R) => {
    var v;
    if (o || R === t)
      return false;
    let g = (v = i.find((h) => h.propsRef.current.value === R)) == null ? void 0 : v.propsRef.current;
    return (g == null ? void 0 : g.disabled) ? false : (r(R), true);
  }, [r, t, o, i]);
  se({ container: b.current, accept(R) {
    return R.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : R.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(R) {
    R.setAttribute("role", "none");
  } });
  let f = (0, import_react28.useCallback)((R) => {
    if (!b.current)
      return;
    let v = i.filter((h) => h.propsRef.current.disabled === false).map((h) => h.element.current);
    switch (R.key) {
      case "ArrowLeft":
      case "ArrowUp":
        if (R.preventDefault(), R.stopPropagation(), M(v, 2 | 16) === 2) {
          let O = i.find((L) => L.element.current === document.activeElement);
          O && p(O.propsRef.current.value);
        }
        break;
      case "ArrowRight":
      case "ArrowDown":
        if (R.preventDefault(), R.stopPropagation(), M(v, 4 | 16) === 2) {
          let O = i.find((L) => L.element.current === document.activeElement);
          O && p(O.propsRef.current.value);
        }
        break;
      case " ":
        {
          R.preventDefault(), R.stopPropagation();
          let h = i.find((O) => O.element.current === document.activeElement);
          h && p(h.propsRef.current.value);
        }
        break;
    }
  }, [b, i, p]), d = (0, import_react28.useCallback)((R) => (a({ type: 0, ...R }), () => a({ type: 1, id: R.id })), [a]), P = (0, import_react28.useMemo)(() => ({ registerOption: d, firstOption: T, containsCheckedOption: y, change: p, disabled: o, value: t }), [d, T, y, p, o, t]), C = { ref: b, id: m, role: "radiogroup", "aria-labelledby": l, "aria-describedby": u, onKeyDown: f };
  return import_react28.default.createElement(c, { name: "RadioGroup.Description" }, import_react28.default.createElement(s, { name: "RadioGroup.Label" }, import_react28.default.createElement(jt.Provider, { value: P }, E({ props: { ...n, ...C }, defaultTag: Qi, name: "RadioGroup" }))));
}
var qi = "div";
function zi(e) {
  let t = (0, import_react28.useRef)(null), r = `headlessui-radiogroup-option-${A()}`, [o, n] = Ae(), [i, a] = re(), { addFlag: l, removeFlag: s, hasFlag: u } = wo(1), { value: c, disabled: m = false, ...b } = e, T = (0, import_react28.useRef)({ value: c, disabled: m });
  x(() => {
    T.current.value = c;
  }, [c, T]), x(() => {
    T.current.disabled = m;
  }, [m, T]);
  let { registerOption: y, disabled: p, change: f, firstOption: d, containsCheckedOption: P, value: C } = Ho("RadioGroup.Option");
  x(() => y({ id: r, element: t, propsRef: T }), [r, y, t, e]);
  let R = (0, import_react28.useCallback)(() => {
    var V;
    !f(c) || (l(2), (V = t.current) == null || V.focus());
  }, [l, f, c]), g = (0, import_react28.useCallback)(() => l(2), [l]), v = (0, import_react28.useCallback)(() => s(2), [s]), h = (d == null ? void 0 : d.id) === r, O = p || m, L = C === c, N = { ref: t, id: r, role: "radio", "aria-checked": L ? "true" : "false", "aria-labelledby": o, "aria-describedby": i, "aria-disabled": O ? true : void 0, tabIndex: (() => O ? -1 : L || !P && h ? 0 : -1)(), onClick: O ? void 0 : R, onFocus: O ? void 0 : g, onBlur: O ? void 0 : v }, K = (0, import_react28.useMemo)(() => ({ checked: L, disabled: O, active: u(2) }), [L, O, u]);
  return import_react28.default.createElement(a, { name: "RadioGroup.Description" }, import_react28.default.createElement(n, { name: "RadioGroup.Label" }, E({ props: { ...b, ...N }, slot: K, defaultTag: qi, name: "RadioGroup.Option" })));
}
lt.Option = zi;
lt.Label = nt;
lt.Description = me;
var $t = (0, import_react31.createContext)(null);
$t.displayName = "GroupContext";
var tl = import_react31.Fragment;
function ol(e) {
  let [t, r] = (0, import_react31.useState)(null), [o, n] = Ae(), [i, a] = re(), l = (0, import_react31.useMemo)(() => ({ switch: t, setSwitch: r, labelledby: o, describedby: i }), [t, r, o, i]);
  return import_react31.default.createElement(a, { name: "Switch.Description" }, import_react31.default.createElement(n, { name: "Switch.Label", props: { onClick() {
    !t || (t.click(), t.focus({ preventScroll: true }));
  } } }, import_react31.default.createElement($t.Provider, { value: l }, E({ props: e, defaultTag: tl, name: "Switch.Group" }))));
}
var rl = "button";
function Qt(e) {
  let { checked: t, onChange: r, ...o } = e, n = `headlessui-switch-${A()}`, i = (0, import_react31.useContext)($t), a = (0, import_react31.useRef)(null), l = I(a, i === null ? null : i.setSwitch), s = (0, import_react31.useCallback)(() => r(!t), [r, t]), u = (0, import_react31.useCallback)((y) => {
    if (G(y.currentTarget))
      return y.preventDefault();
    y.preventDefault(), s();
  }, [s]), c = (0, import_react31.useCallback)((y) => {
    y.key !== "Tab" && y.preventDefault(), y.key === " " && s();
  }, [s]), m = (0, import_react31.useCallback)((y) => y.preventDefault(), []), b = (0, import_react31.useMemo)(() => ({ checked: t }), [t]), T = { id: n, ref: l, role: "switch", type: U(e, a), tabIndex: 0, "aria-checked": t, "aria-labelledby": i == null ? void 0 : i.labelledby, "aria-describedby": i == null ? void 0 : i.describedby, onClick: u, onKeyUp: c, onKeyPress: m };
  return E({ props: { ...o, ...T }, slot: b, defaultTag: rl, name: "Switch" });
}
Qt.Group = ol;
Qt.Label = nt;
Qt.Description = me;
var ul = { [0](e, t) {
  return e.selectedIndex === t.index ? e : { ...e, selectedIndex: t.index };
}, [1](e, t) {
  return e.orientation === t.orientation ? e : { ...e, orientation: t.orientation };
}, [2](e, t) {
  return e.activation === t.activation ? e : { ...e, activation: t.activation };
}, [3](e, t) {
  return e.tabs.includes(t.tab) ? e : { ...e, tabs: [...e.tabs, t.tab] };
}, [4](e, t) {
  return { ...e, tabs: e.tabs.filter((r) => r !== t.tab) };
}, [5](e, t) {
  return e.panels.includes(t.panel) ? e : { ...e, panels: [...e.panels, t.panel] };
}, [6](e, t) {
  return { ...e, panels: e.panels.filter((r) => r !== t.panel) };
}, [7](e) {
  return { ...e };
} };
var zt = (0, import_react32.createContext)(null);
zt.displayName = "TabsContext";
function Le(e) {
  let t = (0, import_react32.useContext)(zt);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Le), r;
  }
  return t;
}
function pl(e, t) {
  return S(t.type, ul, e, t);
}
var dl = import_react32.Fragment;
function cl(e) {
  let { defaultIndex: t = 0, vertical: r = false, manual: o = false, onChange: n, selectedIndex: i = null, ...a } = e, l = r ? "vertical" : "horizontal", s = o ? "manual" : "auto", [u, c] = (0, import_react32.useReducer)(pl, { selectedIndex: null, tabs: [], panels: [], orientation: l, activation: s }), m = (0, import_react32.useMemo)(() => ({ selectedIndex: u.selectedIndex }), [u.selectedIndex]), b = (0, import_react32.useRef)(() => {
  });
  (0, import_react32.useEffect)(() => {
    c({ type: 1, orientation: l });
  }, [l]), (0, import_react32.useEffect)(() => {
    c({ type: 2, activation: s });
  }, [s]), (0, import_react32.useEffect)(() => {
    typeof n == "function" && (b.current = n);
  }, [n]), (0, import_react32.useEffect)(() => {
    if (u.tabs.length <= 0 || i === null && u.selectedIndex !== null)
      return;
    let p = u.tabs.map((P) => P.current).filter(Boolean), f = p.filter((P) => !P.hasAttribute("disabled")), d = i != null ? i : t;
    if (d < 0)
      c({ type: 0, index: p.indexOf(f[0]) });
    else if (d > u.tabs.length)
      c({ type: 0, index: p.indexOf(f[f.length - 1]) });
    else {
      let P = p.slice(0, d), R = [...p.slice(d), ...P].find((g) => f.includes(g));
      if (!R)
        return;
      c({ type: 0, index: p.indexOf(R) });
    }
  }, [t, i, u.tabs, u.selectedIndex]);
  let T = (0, import_react32.useRef)(u.selectedIndex);
  (0, import_react32.useEffect)(() => {
    T.current = u.selectedIndex;
  }, [u.selectedIndex]);
  let y = (0, import_react32.useMemo)(() => [u, { dispatch: c, change(p) {
    T.current !== p && b.current(p), T.current = p, c({ type: 0, index: p });
  } }], [u, c]);
  return import_react32.default.createElement(zt.Provider, { value: y }, E({ props: { ...a }, slot: m, defaultTag: dl, name: "Tabs" }));
}
var fl = "div";
function ml(e) {
  let [{ selectedIndex: t, orientation: r }] = Le("Tab.List"), o = { selectedIndex: t };
  return E({ props: { ...e, ...{ role: "tablist", "aria-orientation": r } }, slot: o, defaultTag: fl, name: "Tabs.List" });
}
var bl = "button";
function De(e) {
  var C, R;
  let t = `headlessui-tabs-tab-${A()}`, [{ selectedIndex: r, tabs: o, panels: n, orientation: i, activation: a }, { dispatch: l, change: s }] = Le(De.name), u = (0, import_react32.useRef)(null), c = I(u, (g) => {
    !g || l({ type: 7 });
  });
  x(() => (l({ type: 3, tab: u }), () => l({ type: 4, tab: u })), [l, u]);
  let m = o.indexOf(u), b = m === r, T = (0, import_react32.useCallback)((g) => {
    let v = o.map((h) => h.current).filter(Boolean);
    if (g.key === " " || g.key === "Enter") {
      g.preventDefault(), g.stopPropagation(), s(m);
      return;
    }
    switch (g.key) {
      case "Home":
      case "PageUp":
        return g.preventDefault(), g.stopPropagation(), M(v, 1);
      case "End":
      case "PageDown":
        return g.preventDefault(), g.stopPropagation(), M(v, 8);
    }
    return S(i, { vertical() {
      if (g.key === "ArrowUp")
        return M(v, 2 | 16);
      if (g.key === "ArrowDown")
        return M(v, 4 | 16);
    }, horizontal() {
      if (g.key === "ArrowLeft")
        return M(v, 2 | 16);
      if (g.key === "ArrowRight")
        return M(v, 4 | 16);
    } });
  }, [o, i, m, s]), y = (0, import_react32.useCallback)(() => {
    var g;
    (g = u.current) == null || g.focus();
  }, [u]), p = (0, import_react32.useCallback)(() => {
    var g;
    (g = u.current) == null || g.focus(), s(m);
  }, [s, m, u]), f = (0, import_react32.useMemo)(() => ({ selected: b }), [b]), d = { ref: c, onKeyDown: T, onFocus: a === "manual" ? y : p, onClick: p, id: t, role: "tab", type: U(e, u), "aria-controls": (R = (C = n[m]) == null ? void 0 : C.current) == null ? void 0 : R.id, "aria-selected": b, tabIndex: b ? 0 : -1 };
  return E({ props: { ...e, ...d }, slot: f, defaultTag: bl, name: "Tabs.Tab" });
}
var Tl = "div";
function yl(e) {
  let [{ selectedIndex: t }] = Le("Tab.Panels"), r = (0, import_react32.useMemo)(() => ({ selectedIndex: t }), [t]);
  return E({ props: e, slot: r, defaultTag: Tl, name: "Tabs.Panels" });
}
var gl = "div";
var Pl = 1 | 2;
function xl(e) {
  var T, y;
  let [{ selectedIndex: t, tabs: r, panels: o }, { dispatch: n }] = Le("Tab.Panel"), i = `headlessui-tabs-panel-${A()}`, a = (0, import_react32.useRef)(null), l = I(a, (p) => {
    !p || n({ type: 7 });
  });
  x(() => (n({ type: 5, panel: a }), () => n({ type: 6, panel: a })), [n, a]);
  let s = o.indexOf(a), u = s === t, c = (0, import_react32.useMemo)(() => ({ selected: u }), [u]), m = { ref: l, id: i, role: "tabpanel", "aria-labelledby": (y = (T = r[s]) == null ? void 0 : T.current) == null ? void 0 : y.id, tabIndex: u ? 0 : -1 };
  return E({ props: { ...e, ...m }, slot: c, defaultTag: gl, features: Pl, visible: u, name: "Tabs.Panel" });
}
De.Group = cl;
De.List = ml;
De.Panels = yl;
De.Panel = xl;
function Bo() {
  let e = (0, import_react34.useRef)(true);
  return (0, import_react34.useEffect)(() => {
    e.current = false;
  }, []), e.current;
}
function No(e) {
  let t = { called: false };
  return (...r) => {
    if (!t.called)
      return t.called = true, e(...r);
  };
}
function Yt(e, ...t) {
  e && t.length > 0 && e.classList.add(...t);
}
function ut(e, ...t) {
  e && t.length > 0 && e.classList.remove(...t);
}
function El(e, t) {
  let r = k();
  if (!e)
    return r.dispose;
  let { transitionDuration: o, transitionDelay: n } = getComputedStyle(e), [i, a] = [o, n].map((l) => {
    let [s = 0] = l.split(",").filter(Boolean).map((u) => u.includes("ms") ? parseFloat(u) : parseFloat(u) * 1e3).sort((u, c) => c - u);
    return s;
  });
  return i !== 0 ? r.setTimeout(() => {
    t("finished");
  }, i + a) : t("finished"), r.add(() => t("cancelled")), r.dispose;
}
function Xt(e, t, r, o, n, i) {
  let a = k(), l = i !== void 0 ? No(i) : () => {
  };
  return ut(e, ...n), Yt(e, ...t, ...r), a.nextFrame(() => {
    ut(e, ...r), Yt(e, ...o), a.add(El(e, (s) => (ut(e, ...o, ...t), Yt(e, ...n), l(s))));
  }), a.add(() => ut(e, ...t, ...r, ...o, ...n)), a.add(() => l("cancelled")), a.dispose;
}
function le(e = "") {
  return (0, import_react33.useMemo)(() => e.split(" ").filter((t) => t.trim().length > 1), [e]);
}
var dt = (0, import_react33.createContext)(null);
dt.displayName = "TransitionContext";
function Cl() {
  let e = (0, import_react33.useContext)(dt);
  if (e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e;
}
function Sl() {
  let e = (0, import_react33.useContext)(ct);
  if (e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e;
}
var ct = (0, import_react33.createContext)(null);
ct.displayName = "NestingContext";
function ft(e) {
  return "children" in e ? ft(e.children) : e.current.filter(({ state: t }) => t === "visible").length > 0;
}
function $o(e) {
  let t = (0, import_react33.useRef)(e), r = (0, import_react33.useRef)([]), o = Be();
  (0, import_react33.useEffect)(() => {
    t.current = e;
  }, [e]);
  let n = (0, import_react33.useCallback)((a, l = 1) => {
    var u;
    let s = r.current.findIndex(({ id: c }) => c === a);
    s !== -1 && (S(l, { [0]() {
      r.current.splice(s, 1);
    }, [1]() {
      r.current[s].state = "hidden";
    } }), !ft(r) && o.current && ((u = t.current) == null || u.call(t)));
  }, [t, o, r]), i = (0, import_react33.useCallback)((a) => {
    let l = r.current.find(({ id: s }) => s === a);
    return l ? l.state !== "visible" && (l.state = "visible") : r.current.push({ id: a, state: "visible" }), () => n(a, 0);
  }, [r, n]);
  return (0, import_react33.useMemo)(() => ({ children: r, register: i, unregister: n }), [i, n, r]);
}
function Al() {
}
var hl = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function Qo(e) {
  var r;
  let t = {};
  for (let o of hl)
    t[o] = (r = e[o]) != null ? r : Al;
  return t;
}
function Ol(e) {
  let t = (0, import_react33.useRef)(Qo(e));
  return (0, import_react33.useEffect)(() => {
    t.current = Qo(e);
  }, [e]), t;
}
var Il = "div";
var qo = 1;
function zo(e) {
  let { beforeEnter: t, afterEnter: r, beforeLeave: o, afterLeave: n, enter: i, enterFrom: a, enterTo: l, entered: s, leave: u, leaveFrom: c, leaveTo: m, ...b } = e, T = (0, import_react33.useRef)(null), [y, p] = (0, import_react33.useState)("visible"), f = b.unmount ? 0 : 1, { show: d, appear: P, initial: C } = Cl(), { register: R, unregister: g } = Sl(), v = A(), h = (0, import_react33.useRef)(false), O = $o(() => {
    h.current || (p("hidden"), g(v), X.current.afterLeave());
  });
  x(() => {
    if (!!v)
      return R(v);
  }, [R, v]), x(() => {
    if (f === 1 && !!v) {
      if (d && y !== "visible") {
        p("visible");
        return;
      }
      S(y, { hidden: () => g(v), visible: () => R(v) });
    }
  }, [y, v, R, g, d, f]);
  let L = le(i), N = le(a), K = le(l), V = le(s), Fe = le(u), ge = le(c), we = le(m), X = Ol({ beforeEnter: t, afterEnter: r, beforeLeave: o, afterLeave: n }), F = q();
  (0, import_react33.useEffect)(() => {
    if (F && y === "visible" && T.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [T, y, F]);
  let $ = C && !P;
  x(() => {
    let bt = T.current;
    if (!!bt && !$)
      return h.current = true, d && X.current.beforeEnter(), d || X.current.beforeLeave(), d ? Xt(bt, L, N, K, V, (Tt) => {
        h.current = false, Tt === "finished" && X.current.afterEnter();
      }) : Xt(bt, Fe, ge, we, V, (Tt) => {
        h.current = false, Tt === "finished" && (ft(O) || (p("hidden"), g(v), X.current.afterLeave()));
      });
  }, [X, v, h, g, O, T, $, d, L, N, K, Fe, ge, we]);
  let H = { ref: T }, Pe = b;
  return import_react33.default.createElement(ct.Provider, { value: O }, import_react33.default.createElement(W, { value: S(y, { visible: 0, hidden: 1 }) }, E({ props: { ...Pe, ...H }, defaultTag: Il, features: qo, visible: y === "visible", name: "Transition.Child" })));
}
function mt(e) {
  let { show: t, appear: r = false, unmount: o, ...n } = e, i = _();
  if (t === void 0 && i !== null && (t = S(i, { [0]: true, [1]: false })), ![true, false].includes(t))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [a, l] = (0, import_react33.useState)(t ? "visible" : "hidden"), s = $o(() => {
    l("hidden");
  }), u = Bo(), c = (0, import_react33.useMemo)(() => ({ show: t, appear: r || !u, initial: u }), [t, r, u]);
  (0, import_react33.useEffect)(() => {
    t ? l("visible") : ft(s) || l("hidden");
  }, [t, s]);
  let m = { unmount: o };
  return import_react33.default.createElement(ct.Provider, { value: s }, import_react33.default.createElement(dt.Provider, { value: c }, E({ props: { ...m, as: import_react33.Fragment, children: import_react33.default.createElement(zo, { ...m, ...n }) }, defaultTag: import_react33.Fragment, features: qo, visible: a === "visible", name: "Transition" })));
}
mt.Child = function(t) {
  let r = (0, import_react33.useContext)(dt) !== null, o = _() !== null;
  return !r && o ? import_react33.default.createElement(mt, { ...t }) : import_react33.default.createElement(zo, { ...t });
};
mt.Root = mt;

// src/lib/use-select-popper.tsx
var import_react35 = require("react");

// node_modules/react-popper/lib/esm/utils.js
var React2 = __toESM(require("react"));
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref) {
    var key = _ref[0], value = _ref[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React2.useLayoutEffect : React2.useEffect;

// node_modules/react-popper/lib/esm/usePopper.js
var React3 = __toESM(require("react"));

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y
  }) : {
    x: x2,
    y
  };
  x2 = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y
  }) : {
    x: x2,
    y
  };
  x2 = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y + "px)" : "translate3d(" + x2 + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i3) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i3).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
      var _ret = _loop(_i2);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/react-popper/lib/esm/usePopper.js
var import_react_fast_compare = __toESM(require_react_fast_compare());
var EMPTY_MODIFIERS = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = React3.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  var _React$useState = React3.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = React3.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn2(_ref) {
        var state2 = _ref.state;
        var elements = Object.keys(state2.elements);
        setState({
          styles: fromEntries(elements.map(function(element) {
            return [element, state2.styles[element] || {}];
          })),
          attributes: fromEntries(elements.map(function(element) {
            return [element, state2.attributes[element]];
          }))
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = React3.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = React3.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper2 = options.createPopper || createPopper;
    var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

// src/lib/use-select-popper.tsx
var useSelectPopper = ({
  offset: offset2 = [0, 10]
}) => {
  const [element, setElement] = (0, import_react35.useState)(null);
  const [popper2, setPopper] = (0, import_react35.useState)(null);
  const { styles, attributes } = usePopper(element, popper2, {
    placement: "bottom",
    strategy: "fixed",
    modifiers: [{ name: "offset", options: { offset: offset2 } }]
  });
  return (0, import_react35.useMemo)(() => ({
    element,
    setElement,
    popper: popper2,
    setPopper,
    styles,
    attributes
  }), [element, setElement, popper2, setPopper, styles, attributes]);
};

// src/lib/guest-select.tsx
var getCountDisplayText = (fieldItem, mode) => {
  if (mode === "all") {
    const count = fieldItem == null ? void 0 : fieldItem.totalCount;
    return count ? `${count} guest${count > 1 ? "s" : ""}` : "";
  }
  if (mode === "each") {
    let result = "";
    fieldItem.value.forEach((value) => {
      const separator = result ? " | " : "";
      if (!value.value)
        return;
      result = result.concat(`${separator}${value.value} ${value.name}`);
    });
    return result;
  }
  return mode == null ? void 0 : mode(fieldItem);
};
var GuestSelect = ({
  form,
  name,
  menu: Menu,
  option: OptionComponent,
  menuContainer: MenuContainer,
  inputComponent: InputComponent,
  okButton: OkButton,
  okText = "Ok",
  placeholder,
  offset: offset2,
  countTextFormat = "all",
  portal: PortalInput
}) => {
  var _a;
  const formStateItem = (_a = form == null ? void 0 : form.state) == null ? void 0 : _a[name];
  const options = formStateItem.value;
  const {
    element,
    setElement,
    setPopper,
    styles,
    attributes
  } = useSelectPopper({
    offset: offset2
  });
  (0, import_react36.useEffect)(() => {
    form.refs[name].current = element;
  }, [element]);
  const value = getCountDisplayText(form.state[name], countTextFormat);
  const onOkButtonClick = () => {
    element == null ? void 0 : element.click();
  };
  const PortalComponent = PortalInput || We;
  return /* @__PURE__ */ import_react36.default.createElement(Te, {
    as: import_react36.default.Fragment
  }, ({ open }) => /* @__PURE__ */ import_react36.default.createElement(import_react36.default.Fragment, null, /* @__PURE__ */ import_react36.default.createElement(Te.Button, {
    value,
    ref: setElement,
    as: InputComponent,
    placeholder,
    name,
    form,
    readOnly: true
  }), /* @__PURE__ */ import_react36.default.createElement(PortalComponent, null, /* @__PURE__ */ import_react36.default.createElement(Te.Panel, {
    as: MenuContainer,
    ref: setPopper,
    static: true,
    style: { ...styles.popper, pointerEvents: open ? "" : "none" },
    ...attributes.popper
  }, /* @__PURE__ */ import_react36.default.createElement(Menu, {
    open
  }, options.map((option) => /* @__PURE__ */ import_react36.default.createElement(OptionComponent, {
    key: option.name,
    form,
    name,
    option
  })), !!OkButton && /* @__PURE__ */ import_react36.default.createElement(OkButton, {
    onClick: onOkButtonClick
  }, okText))))));
};

// src/lib/location-select.tsx
var import_react39 = __toESM(require("react"));

// src/lib/use-location-data.ts
var import_react38 = require("react");
var import_debounce_promise = __toESM(require_dist());
var useLocationData = ({
  form,
  name,
  debounceDelay,
  formatResults
}) => {
  var _a, _b;
  const formSchemaItem = (_a = form == null ? void 0 : form.formSchema) == null ? void 0 : _a[name];
  const [isLoading, setIsLoading] = (0, import_react38.useState)(false);
  const [options, setOptions] = (0, import_react38.useState)(((_b = formSchemaItem == null ? void 0 : formSchemaItem.options) == null ? void 0 : _b.defaultLocationOptions) || []);
  const getPlaces = async (queryString) => {
    const options2 = formSchemaItem == null ? void 0 : formSchemaItem.options;
    if (!(options2 == null ? void 0 : options2.searchPlace))
      return;
    setIsLoading(true);
    return await options2.searchPlace(queryString).then((results) => {
      setIsLoading(false);
      const options3 = (formatResults == null ? void 0 : formatResults(results)) || results;
      setOptions(options3);
    });
  };
  const loadOptionsDebounce = (0, import_react38.useRef)((0, import_debounce_promise.default)(getPlaces, debounceDelay, { leading: false }));
  const loadOptions = (0, import_react38.useRef)((input) => loadOptionsDebounce.current(input));
  return (0, import_react38.useMemo)(() => ({ options, isLoading, loadOptions }), [
    options,
    isLoading,
    loadOptions
  ]);
};

// src/lib/location-select.tsx
var ExtendedOption = import_react39.default.forwardRef(({
  active,
  selected,
  Option,
  onClick = void 0,
  form,
  element,
  name,
  option,
  ...props
}, ref) => {
  const realOnClick = () => {
    var _a;
    form.setFieldState(name, { value: option });
    (_a = element == null ? void 0 : element.focus) == null ? void 0 : _a.call(element);
    setTimeout(() => {
      const focusOnNext = form.formSchema[name].focusOnNext;
      form.focusOn(focusOnNext);
    }, 100);
  };
  return /* @__PURE__ */ import_react39.default.createElement(Option, {
    $active: active,
    $selected: selected,
    onClick: realOnClick,
    ref,
    ...props
  }, option.label);
});
var LocationSelect = ({
  form,
  menu: Menu,
  menuContainer: MenuContainer,
  option: Option,
  inputComponent: InputComponent,
  emptyOption,
  debounceDelay = 500,
  selectOnClick = true,
  name,
  formatResults,
  autoComplete = "off",
  placeholder,
  offset: offset2,
  portal: PortalInput
}) => {
  var _a;
  const formStateItem = (_a = form == null ? void 0 : form.state) == null ? void 0 : _a[name];
  const {
    element,
    setElement,
    setPopper,
    styles,
    attributes
  } = useSelectPopper({
    offset: offset2
  });
  const btn = (0, import_react39.useRef)(null);
  const { loadOptions, isLoading, options } = useLocationData({
    debounceDelay,
    formatResults,
    name,
    form
  });
  const onChange = (event) => {
    loadOptions.current(event.target.value);
  };
  const onSelect = (option) => {
    form.setFieldState(name, { value: option });
    setTimeout(() => {
      var _a2, _b;
      const focusOnNext = form.formSchema[name].focusOnNext;
      if (!focusOnNext)
        return;
      const formItem = form.formSchema[focusOnNext];
      if (formItem.type === "location")
        return (_b = (_a2 = form.refs[focusOnNext]) == null ? void 0 : _a2.current) == null ? void 0 : _b.focus();
      form.focusOn(focusOnNext);
    }, 50);
  };
  const onFocus = () => {
    var _a2, _b, _c;
    (_b = (_a2 = btn == null ? void 0 : btn.current) == null ? void 0 : _a2.click) == null ? void 0 : _b.call(_a2);
    if (selectOnClick) {
      (_c = element == null ? void 0 : element.select) == null ? void 0 : _c.call(element);
    }
  };
  (0, import_react39.useEffect)(() => {
    form.refs[name].current = element;
  }, [element]);
  const PortalComponent = PortalInput || We;
  return /* @__PURE__ */ import_react39.default.createElement(Na, {
    value: formStateItem.value,
    onChange: onSelect
  }, ({ open }) => /* @__PURE__ */ import_react39.default.createElement(import_react39.default.Fragment, null, /* @__PURE__ */ import_react39.default.createElement(Na.Button, {
    style: { display: "none" },
    ref: btn
  }), /* @__PURE__ */ import_react39.default.createElement(Na.Input, {
    onFocus,
    displayValue: (v) => v == null ? void 0 : v.label,
    onChange,
    ref: setElement,
    isLoading,
    as: InputComponent,
    placeholder,
    autoComplete,
    name,
    form
  }), /* @__PURE__ */ import_react39.default.createElement(PortalComponent, null, /* @__PURE__ */ import_react39.default.createElement(Na.Options, {
    as: MenuContainer,
    ref: setPopper,
    static: true,
    style: { ...styles.popper, pointerEvents: open ? "" : "none" },
    ...attributes.popper
  }, /* @__PURE__ */ import_react39.default.createElement(Menu, {
    open
  }, !options.length && (typeof emptyOption === "function" ? emptyOption() : /* @__PURE__ */ import_react39.default.createElement(Option, {
    $disabled: true
  }, emptyOption)), options.map((option) => /* @__PURE__ */ import_react39.default.createElement(Na.Option, {
    key: option.value,
    value: option,
    as: import_react39.default.Fragment
  }, ({ active, selected }) => /* @__PURE__ */ import_react39.default.createElement(ExtendedOption, {
    active,
    selected,
    option,
    Option,
    form,
    element,
    name
  }, option.label))))))));
};

// src/lib/utils/index.ts
var mergeRefs = (...refs) => {
  return (node) => {
    for (const ref of refs) {
      ref.current = node;
    }
  };
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* flatpickr v4.6.9, @license MIT */
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
